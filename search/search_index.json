{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"v2/installation/","text":"This Is Only a Placeholder The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"v2/installation/#this-is-only-a-placeholder","text":"The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This Is Only a Placeholder"},{"location":"v2/intro/","text":"Introduction laminas-validator provides a set of commonly needed validators. It also provides a simple validator chaining mechanism by which multiple validators may be applied to a single datum in a user-defined order. What is a validator? A validator examines its input with respect to some requirements and produces a boolean result indicating whether the input successfully validates against the requirements. If the input does not meet the requirements, a validator may additionally provide information about which requirement(s) the input does not meet. For example, a web application might require that a username be between six and twelve characters in length, and may only contain alphanumeric characters. A validator can be used for ensuring that a username meets these requirements. If a chosen username does not meet one or both of the requirements, it would be useful to know which of the requirements the username fails to meet. Basic usage of validators Having defined validation in this way provides the foundation for Laminas\\Validator\\ValidatorInterface , which defines two methods, isValid() and getMessages() . The isValid() method performs validation upon the provided value, returning true if and only if the value passes against the validation criteria. If isValid() returns false , the getMessages() method will return an array of messages explaining the reason(s) for validation failure. The array keys are short strings that identify the reasons for validation failure, and the array values are the corresponding human-readable string messages. The keys and values are class-dependent; each validation class defines its own set of validation failure messages and the unique keys that identify them. Each class also has a const definition that matches each identifier for a validation failure cause. Stateful validators The getMessages() methods return validation failure information only for the most recent isValid() call. Each call to isValid() clears any messages and errors caused by a previous isValid() call, because it's likely that each call to isValid() is made for a different input value. The following example illustrates validation of an e-mail address: use Laminas\\Validator\\EmailAddress; $validator = new EmailAddress(); if ($validator-&gt;isValid($email)) { // email appears to be valid } else { // email is invalid; print the reasons foreach ($validator-&gt;getMessages() as $messageId =&gt; $message) { printf(\"Validation failure '%s': %s\\n\", $messageId, $message); } } Customizing messages Validator classes provide a setMessage() method with which you can specify the format of a message returned by getMessages() in case of validation failure. The first argument of this method is a string containing the error message. You can include tokens in this string which will be substituted with data relevant to the validator. The token %value% is supported by all validators; this is substituted with the value you passed to isValid() . Other tokens may be supported on a case-by-case basis in each validation class. For example, %max% is a token supported by Laminas\\Validator\\LessThan . The getMessageVariables() method returns an array of variable tokens supported by the validator. The second optional argument is a string that identifies the validation failure message template to be set, which is useful when a validation class defines more than one cause for failure. If you omit the second argument, setMessage() assumes the message you specify should be used for the first message template declared in the validation class. Many validation classes only have one error message template defined, so there is no need to specify which message template you are changing. use Laminas\\Validator\\StringLength; $validator = new StringLength(8); $validator-&gt;setMessage( 'The string \\'%value%\\' is too short; it must be at least %min% characters', StringLength::TOO_SHORT ); if (! $validator-&gt;isValid('word')) { $messages = $validator-&gt;getMessages(); echo current($messages); // \"The string 'word' is too short; it must be at least 8 characters\" } You can set multiple messages using the setMessages() method. Its argument is an array containing key/message pairs. use Laminas\\Validator\\StringLength; $validator = new StringLength(['min' =&gt; 8, 'max' =&gt; 12]); $validator-&gt;setMessages([ StringLength::TOO_SHORT =&gt; 'The string \\'%value%\\' is too short', StringLength::TOO_LONG =&gt; 'The string \\'%value%\\' is too long', ]); If your application requires even greater flexibility with which it reports validation failures, you can access properties by the same name as the message tokens supported by a given validation class. The value property is always available in a validator; it is the value you specified as the argument of isValid() . Other properties may be supported on a case-by-case basis in each validation class. use Laminas\\Validator\\StringLength; $validator = new StringLength(['min' =&gt; 8, 'max' =&gt; 12]); if (! $validator-&gt;isValid('word')) { printf( \"Word failed: %s; its length is not between %d and %d\\n\", $validator-&gt;value, $validator-&gt;min, $validator-&gt;max ); } Translating messages Installation requirements The translation of validator messages depends on the laminas-i18n component, so be sure to have it installed before getting started: $ composer require laminas/laminas-i18n Validator classes provide a setTranslator() method with which you can specify an instance of Laminas\\Validator\\Translator\\TranslatorInterface which will translate the messages in case of a validation failure. The getTranslator() method returns the translator instance. Laminas\\Mvc\\I18n\\Translator provides an implementation compatible with the validator component. use Laminas\\Mvc\\I18n\\Translator; use Laminas\\Validator\\StringLength; $validator = new StringLength(['min' =&gt; 8, 'max' =&gt; 12]); $translate = new Translator(); // configure the translator... $validator-&gt;setTranslator($translate); With the static AbstractValidator::setDefaultTranslator() method you can set a instance of Laminas\\Validator\\Translator\\TranslatorInterface which will be used for all validation classes, and can be retrieved with getDefaultTranslator() . This prevents the need for setting a translator manually with each validator. use Laminas\\Mvc\\I18n\\Translator; use Laminas\\Validator\\AbstractValidator; $translate = new Translator(); // configure the translator... AbstractValidator::setDefaultTranslator($translate); Sometimes it is necessary to disable the translator within a validator. To achieve this you can use the setDisableTranslator() method, which accepts a boolean parameter, and isTranslatorDisabled() to get the set value. use Laminas\\Validator\\StringLength; $validator = new StringLength(['min' =&gt; 8, 'max' =&gt; 12]); if (! $validator-&gt;isTranslatorDisabled()) { $validator-&gt;setDisableTranslator(); } It is also possible to use a translator instead of setting own messages with setMessage() . But doing so, you should keep in mind, that the translator works also on messages you set your own. Translation compatibility In versions 2.0 - 2.1, Laminas\\Validator\\AbstractValidator implemented Laminas\\I18n\\Translator\\TranslatorAwareInterface and accepted instances of Laminas\\I18n\\Translator\\Translator . Starting in version 2.2.0, laminas-validator now defines a translator interface, &gt; Laminas\\Validator\\Translator\\TranslatorInterface , as well as it's own -aware variant, &gt; Laminas\\Validator\\Translator\\TranslatorAwareInterface . This was done to reduce dependencies for the component, and follows the principal of Separated Interfaces. The upshot is that if you are migrating from a pre-2.2 version, and receiving errors indicating that the translator provided does not implement Laminas\\Validator\\Translator\\TranslatorInterface , you will need to make a change to your code. An implementation of Laminas\\Validator\\Translator\\TranslatorInterface is provided in Laminas\\Mvc\\I18n\\Translator , which also extends Laminas\\I18n\\Translator\\Translator . This version can be instantiated and used just as the original Laminas\\I18n version. A new service has also been registered with the MVC, MvcTranslator , which will return this specialized, bridge instance. Most users should see no issues, as Laminas\\Validator\\ValidatorPluginManager has been modified to use the MvcTranslator service internally, which is how most developers were getting the translator instance into validators in the first place. You will only need to change code if you were manually injecting the instance previously.","title":"Introduction"},{"location":"v2/intro/#introduction","text":"laminas-validator provides a set of commonly needed validators. It also provides a simple validator chaining mechanism by which multiple validators may be applied to a single datum in a user-defined order.","title":"Introduction"},{"location":"v2/intro/#what-is-a-validator","text":"A validator examines its input with respect to some requirements and produces a boolean result indicating whether the input successfully validates against the requirements. If the input does not meet the requirements, a validator may additionally provide information about which requirement(s) the input does not meet. For example, a web application might require that a username be between six and twelve characters in length, and may only contain alphanumeric characters. A validator can be used for ensuring that a username meets these requirements. If a chosen username does not meet one or both of the requirements, it would be useful to know which of the requirements the username fails to meet.","title":"What is a validator?"},{"location":"v2/intro/#basic-usage-of-validators","text":"Having defined validation in this way provides the foundation for Laminas\\Validator\\ValidatorInterface , which defines two methods, isValid() and getMessages() . The isValid() method performs validation upon the provided value, returning true if and only if the value passes against the validation criteria. If isValid() returns false , the getMessages() method will return an array of messages explaining the reason(s) for validation failure. The array keys are short strings that identify the reasons for validation failure, and the array values are the corresponding human-readable string messages. The keys and values are class-dependent; each validation class defines its own set of validation failure messages and the unique keys that identify them. Each class also has a const definition that matches each identifier for a validation failure cause.","title":"Basic usage of validators"},{"location":"v2/intro/#customizing-messages","text":"Validator classes provide a setMessage() method with which you can specify the format of a message returned by getMessages() in case of validation failure. The first argument of this method is a string containing the error message. You can include tokens in this string which will be substituted with data relevant to the validator. The token %value% is supported by all validators; this is substituted with the value you passed to isValid() . Other tokens may be supported on a case-by-case basis in each validation class. For example, %max% is a token supported by Laminas\\Validator\\LessThan . The getMessageVariables() method returns an array of variable tokens supported by the validator. The second optional argument is a string that identifies the validation failure message template to be set, which is useful when a validation class defines more than one cause for failure. If you omit the second argument, setMessage() assumes the message you specify should be used for the first message template declared in the validation class. Many validation classes only have one error message template defined, so there is no need to specify which message template you are changing. use Laminas\\Validator\\StringLength; $validator = new StringLength(8); $validator-&gt;setMessage( 'The string \\'%value%\\' is too short; it must be at least %min% characters', StringLength::TOO_SHORT ); if (! $validator-&gt;isValid('word')) { $messages = $validator-&gt;getMessages(); echo current($messages); // \"The string 'word' is too short; it must be at least 8 characters\" } You can set multiple messages using the setMessages() method. Its argument is an array containing key/message pairs. use Laminas\\Validator\\StringLength; $validator = new StringLength(['min' =&gt; 8, 'max' =&gt; 12]); $validator-&gt;setMessages([ StringLength::TOO_SHORT =&gt; 'The string \\'%value%\\' is too short', StringLength::TOO_LONG =&gt; 'The string \\'%value%\\' is too long', ]); If your application requires even greater flexibility with which it reports validation failures, you can access properties by the same name as the message tokens supported by a given validation class. The value property is always available in a validator; it is the value you specified as the argument of isValid() . Other properties may be supported on a case-by-case basis in each validation class. use Laminas\\Validator\\StringLength; $validator = new StringLength(['min' =&gt; 8, 'max' =&gt; 12]); if (! $validator-&gt;isValid('word')) { printf( \"Word failed: %s; its length is not between %d and %d\\n\", $validator-&gt;value, $validator-&gt;min, $validator-&gt;max ); }","title":"Customizing messages"},{"location":"v2/intro/#translating-messages","text":"","title":"Translating messages"},{"location":"v2/messages/","text":"Validation Messages Each validator based on Laminas\\Validator\\ValidatorInterface provides one or multiple messages in the case of a failed validation. You can use this information to set your own messages, or to translate existing messages which a validator could return to something different. Validation messages are defined as constant/template pairs, with the constant representing a translation key. Such constants are defined per-class. Let's look into Laminas\\Validator\\GreaterThan for a descriptive example: protected $messageTemplates = [ self::NOT_GREATER =&gt; \"'%value%' is not greater than '%min%'\", ]; The constant self::NOT_GREATER refers to the failure and is used as the message key, and the message template itself is used as the value within the message array. You can retrieve all message templates from a validator by using the getMessageTemplates() method. It returns the above array containing all messages a validator could return in the case of a failed validation. $validator = new Laminas\\Validator\\GreaterThan(); $messages = $validator-&gt;getMessageTemplates(); Using the setMessage() method you can set another message to be returned in case of the specified failure. use Laminas\\Validator\\GreaterThan; $validator = new GreaterThan(); $validator-&gt;setMessage('Please enter a lower value', GreaterThan::NOT_GREATER); The second parameter defines the failure which will be overridden. When you omit this parameter, then the given message will be set for all possible failures of this validator. Using pre-translated validation messages laminas-validator is shipped with more than 45 different validators with more than 200 failure messages. It can be a tedious task to translate all of these messages. For your convenience, pre-translated messages are provided in the laminas/laminas-i18n-resources package: $ composer require laminas/laminas-i18n-resources To translate all validation messages to German for example, attach a translator to Laminas\\Validator\\AbstractValidator using these resource files. use Laminas\\I18n\\Translator\\Resources; use Laminas\\Mvc\\I18n\\Translator; use Laminas\\Validator\\AbstractValidator; $translator = new Laminas\\Mvc\\I18n\\Translator(); $translator-&gt;addTranslationFilePattern( 'phpArray', Resources::getBasePath(), Resources::getPatternForValidator() ); AbstractValidator::setDefaultTranslator($translator); Supported languages The supported languages may not be complete. New languages will be added with each release. Additionally feel free to use the existing resource files to make your own translations. You could also use these resource files to rewrite existing translations. So you are not in need to create these files manually yourself. Limit the size of a validation message Sometimes it is necessary to limit the maximum size a validation message can have; as an example, when your view allows a maximum size of 100 chars to be rendered on one line. To enable this, Laminas\\Validator\\AbstractValidator is able to automatically limit the maximum returned size of a validation message. To get the actual set size use Laminas\\Validator\\AbstractValidator::getMessageLength() . If it is -1 , then the returned message will not be truncated. This is default behaviour. To limit the returned message size, use Laminas\\Validator\\AbstractValidator::setMessageLength() . Set it to any integer size you need. When the returned message exceeds the set size, then the message will be truncated and the string **...** will be added instead of the rest of the message. Laminas\\Validator\\AbstractValidator::setMessageLength(100); Where is this parameter used? The set message length is used for all validators, even for self defined ones, as long as they extend Laminas\\Validator\\AbstractValidator .","title":"Validation Messages"},{"location":"v2/messages/#validation-messages","text":"Each validator based on Laminas\\Validator\\ValidatorInterface provides one or multiple messages in the case of a failed validation. You can use this information to set your own messages, or to translate existing messages which a validator could return to something different. Validation messages are defined as constant/template pairs, with the constant representing a translation key. Such constants are defined per-class. Let's look into Laminas\\Validator\\GreaterThan for a descriptive example: protected $messageTemplates = [ self::NOT_GREATER =&gt; \"'%value%' is not greater than '%min%'\", ]; The constant self::NOT_GREATER refers to the failure and is used as the message key, and the message template itself is used as the value within the message array. You can retrieve all message templates from a validator by using the getMessageTemplates() method. It returns the above array containing all messages a validator could return in the case of a failed validation. $validator = new Laminas\\Validator\\GreaterThan(); $messages = $validator-&gt;getMessageTemplates(); Using the setMessage() method you can set another message to be returned in case of the specified failure. use Laminas\\Validator\\GreaterThan; $validator = new GreaterThan(); $validator-&gt;setMessage('Please enter a lower value', GreaterThan::NOT_GREATER); The second parameter defines the failure which will be overridden. When you omit this parameter, then the given message will be set for all possible failures of this validator.","title":"Validation Messages"},{"location":"v2/messages/#using-pre-translated-validation-messages","text":"laminas-validator is shipped with more than 45 different validators with more than 200 failure messages. It can be a tedious task to translate all of these messages. For your convenience, pre-translated messages are provided in the laminas/laminas-i18n-resources package: $ composer require laminas/laminas-i18n-resources To translate all validation messages to German for example, attach a translator to Laminas\\Validator\\AbstractValidator using these resource files. use Laminas\\I18n\\Translator\\Resources; use Laminas\\Mvc\\I18n\\Translator; use Laminas\\Validator\\AbstractValidator; $translator = new Laminas\\Mvc\\I18n\\Translator(); $translator-&gt;addTranslationFilePattern( 'phpArray', Resources::getBasePath(), Resources::getPatternForValidator() ); AbstractValidator::setDefaultTranslator($translator);","title":"Using pre-translated validation messages"},{"location":"v2/messages/#limit-the-size-of-a-validation-message","text":"Sometimes it is necessary to limit the maximum size a validation message can have; as an example, when your view allows a maximum size of 100 chars to be rendered on one line. To enable this, Laminas\\Validator\\AbstractValidator is able to automatically limit the maximum returned size of a validation message. To get the actual set size use Laminas\\Validator\\AbstractValidator::getMessageLength() . If it is -1 , then the returned message will not be truncated. This is default behaviour. To limit the returned message size, use Laminas\\Validator\\AbstractValidator::setMessageLength() . Set it to any integer size you need. When the returned message exceeds the set size, then the message will be truncated and the string **...** will be added instead of the rest of the message. Laminas\\Validator\\AbstractValidator::setMessageLength(100);","title":"Limit the size of a validation message"},{"location":"v2/set/","text":"Standard Validation Classes The following validators come with the laminas-validator distribution. Barcode Between Callback CreditCard CSRF (Cross-site request forgery Date DateComparison RecordExists and NoRecordExists (database) Digits EmailAddress Explode File Validation Classes GreaterThan Hex Hostname HostWithPublicIPv4Address Iban Identical InArray Ip IsArray Isbn IsCountable IsInstanceOf LessThan NotEmpty NumberComparison Regex Sitemap Step StringLength Timezone Uri Uuid Additional validators Several other components offer validators as well: laminas-i18n Deprecated Validators Ccnum The Ccnum validator has been deprecated in favor of the CreditCard validator. For security reasons you should use CreditCard instead of Ccnum .","title":"Standard Validation Classes"},{"location":"v2/set/#standard-validation-classes","text":"The following validators come with the laminas-validator distribution. Barcode Between Callback CreditCard CSRF (Cross-site request forgery Date DateComparison RecordExists and NoRecordExists (database) Digits EmailAddress Explode File Validation Classes GreaterThan Hex Hostname HostWithPublicIPv4Address Iban Identical InArray Ip IsArray Isbn IsCountable IsInstanceOf LessThan NotEmpty NumberComparison Regex Sitemap Step StringLength Timezone Uri Uuid","title":"Standard Validation Classes"},{"location":"v2/set/#additional-validators","text":"Several other components offer validators as well: laminas-i18n","title":"Additional validators"},{"location":"v2/set/#deprecated-validators","text":"","title":"Deprecated Validators"},{"location":"v2/validator-chains/","text":"Validator Chains Basic Usage Installation requirements The validator chain depends on the laminas-servicemanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-servicemanager Often, multiple validations should be applied to some value in a particular order. The following code demonstrates a way to solve the example from the introduction , where a username must be between 6 and 12 alphanumeric characters: use Laminas\\I18n\\Validator\\Alnum; use Laminas\\Validator\\StringLength; use Laminas\\Validator\\ValidatorChain; // Create a validator chain and add validators to it $validatorChain = new ValidatorChain(); $validatorChain-&gt;attach(new StringLength(['min' =&gt; 6, 'max' =&gt; 12])); $validatorChain-&gt;attach(new Alnum()); // Validate the username if ($validatorChain-&gt;isValid($username)) { // username passed validation } else { // username failed validation; print reasons foreach ($validatorChain-&gt;getMessages() as $message) { echo \"$message\\n\"; } } Validators are run in the order they were added to the ValidatorChain . In the above example, the username is first checked to ensure that its length is between 6 and 12 characters, and then it is checked to ensure that it contains only alphanumeric characters. The second validation, for alphanumeric characters, is performed regardless of whether the first validation, for length between 6 and 12 characters, succeeds. This means that if both validations fail, getMessages() will return failure messages from both validators. In some cases, it makes sense to have a validator break the chain if its validation process fails. ValidatorChain supports such use cases with the second parameter to the attach() method. By setting $breakChainOnFailure to true , if the validator fails, it will short-circuit execution of the chain, preventing subsequent validators from executing. If the above example were written as follows, then the alphanumeric validation would not occur if the string length validation fails: $chain-&gt;attach(new StringLength(['min' =&gt; 6, 'max' =&gt; 12]), true); $chain-&gt;attach(new Alnum()); Any object that implements Laminas\\Validator\\ValidatorInterface may be used in a validator chain. Setting Validator Chain Order For each validator added to the ValidatorChain , you can set a priority to define the chain order. The default value is 1 . Higher values indicate earlier execution, while lower values execute later; use negative values to force late execution. In the following example, the username is first checked to ensure that its length is between 7 and 9 characters, and then it is checked to ensure that its length is between 3 and 5 characters. use Laminas\\I18n\\Validator\\Alnum; use Laminas\\Validator\\StringLength; use Laminas\\Validator\\ValidatorChain; $username = 'ABCDFE'; // Create a validator chain and add validators to it $validatorChain = new ValidatorChain(); $validatorChain-&gt;attach( new StringLength(['min' =&gt; 3, 'max' =&gt; 5]), true, // break chain on failure 1 ); $validatorChain-&gt;attach( new StringLength(['min' =&gt; 7, 'max' =&gt; 9]), true, // break chain on failure 2 // higher priority! ); // Validate the username if ($validatorChain-&gt;isValid($username)) { // username passed validation echo \"Success\"; } else { // username failed validation; print reasons foreach ($validatorChain-&gt;getMessages() as $message) { echo \"$message\\n\"; } } // This first example will display: The input is less than 7 characters long","title":"Validator Chains"},{"location":"v2/validator-chains/#validator-chains","text":"","title":"Validator Chains"},{"location":"v2/validator-chains/#basic-usage","text":"","title":"Basic Usage"},{"location":"v2/validator-chains/#setting-validator-chain-order","text":"For each validator added to the ValidatorChain , you can set a priority to define the chain order. The default value is 1 . Higher values indicate earlier execution, while lower values execute later; use negative values to force late execution. In the following example, the username is first checked to ensure that its length is between 7 and 9 characters, and then it is checked to ensure that its length is between 3 and 5 characters. use Laminas\\I18n\\Validator\\Alnum; use Laminas\\Validator\\StringLength; use Laminas\\Validator\\ValidatorChain; $username = 'ABCDFE'; // Create a validator chain and add validators to it $validatorChain = new ValidatorChain(); $validatorChain-&gt;attach( new StringLength(['min' =&gt; 3, 'max' =&gt; 5]), true, // break chain on failure 1 ); $validatorChain-&gt;attach( new StringLength(['min' =&gt; 7, 'max' =&gt; 9]), true, // break chain on failure 2 // higher priority! ); // Validate the username if ($validatorChain-&gt;isValid($username)) { // username passed validation echo \"Success\"; } else { // username failed validation; print reasons foreach ($validatorChain-&gt;getMessages() as $message) { echo \"$message\\n\"; } } // This first example will display: The input is less than 7 characters long","title":"Setting Validator Chain Order"},{"location":"v2/writing-validators/","text":"Writing Validators laminas-validator supplies a set of commonly needed validators, but many applications have needs for custom validators. The component allows this via implementations of Laminas\\Validator\\ValidatorInterface . Laminas\\Validator\\ValidatorInterface defines two methods: isValid() and getMessages() . An object that implements the interface may be added to a validator chain using Laminas\\Validator\\ValidatorChain::addValidator() . Such objects may also be used with laminas-inputfilter . Validators will return a boolean value from isValid() , and report information regarding why a value failed validation via getMessages() . The availability of the reasons for validation failures may be valuable to an application for various purposes, such as providing statistics for usability analysis. Basic validation failure message functionality is implemented in Laminas\\Validator\\AbstractValidator , which you may extend for your custom validators. Extending class you would implement the isValid() method logic and define the message variables and message templates that correspond to the types of validation failures that can occur. If a value fails your validation tests, then isValid() should return false . If the value passes your validation tests, then isValid() should return true . In general, the isValid() method should not throw any exceptions, except where it is impossible to determine whether or not the input value is valid. A few examples of reasonable cases for throwing an exception might be if a file cannot be opened, an LDAP server could not be contacted, or a database connection is unavailable, where such a thing may be required for validation success or failure to be determined. Creating a Validation Class The following example demonstrates how a custom validator might be written. In this case, the validator tests that a value is a floating point value. namespace MyValid; use Laminas\\Validator\\AbstractValidator; class Float extends AbstractValidator { const FLOAT = 'float'; protected $messageTemplates = [ self::FLOAT =&gt; \"'%value%' is not a floating point value\", ]; public function isValid($value) { $this-&gt;setValue($value); if (! is_float($value)) { $this-&gt;error(self::FLOAT); return false; } return true; } } The class defines a template for its single validation failure message, which includes the built-in magic parameter, %value% . The call to setValue() prepares the object to insert the tested value into the failure message automatically, should the value fail validation. The call to error() tracks a reason for validation failure. Since this class only defines one failure message, it is not necessary to provide error() with the name of the failure message template. Writing a Validation Class having Dependent Conditions The following example demonstrates a more complex set of validation rules: The input must be numeric. The input must fall within a range of boundary values. An input value would fail validation for exactly one of the following reasons: The input value is not numeric. The input value is less than the minimum allowed value. The input value is more than the maximum allowed value. These validation failure reasons are then translated to definitions in the class: namespace MyValid; use Laminas\\Validator\\AbstractValidator; class NumericBetween extends AbstractValidator { const MSG_NUMERIC = 'msgNumeric'; const MSG_MINIMUM = 'msgMinimum'; const MSG_MAXIMUM = 'msgMaximum'; public $minimum = 0; public $maximum = 100; protected $messageVariables = [ 'min' =&gt; 'minimum', 'max' =&gt; 'maximum', ]; protected $messageTemplates = [ self::MSG_NUMERIC =&gt; \"'%value%' is not numeric\", self::MSG_MINIMUM =&gt; \"'%value%' must be at least '%min%'\", self::MSG_MAXIMUM =&gt; \"'%value%' must be no more than '%max%'\", ]; public function isValid($value) { $this-&gt;setValue($value); if (! is_numeric($value)) { $this-&gt;error(self::MSG_NUMERIC); return false; } if ($value &lt; $this-&gt;minimum) { $this-&gt;error(self::MSG_MINIMUM); return false; } if ($value &gt; $this-&gt;maximum) { $this-&gt;error(self::MSG_MAXIMUM); return false; } return true; } } The public properties $minimum and $maximum have been established to provide the minimum and maximum boundaries, respectively, for a value to successfully validate. The class also defines two message variables that correspond to the public properties and allow min and max to be used in message templates as magic parameters, just as with value . Note that if any one of the validation checks in isValid() fails, an appropriate failure message is prepared, and the method immediately returns false . These validation rules are therefore sequentially dependent; that is, if one test should fail, there is no need to test any subsequent validation rules. This need not be the case, however. The following example illustrates how to write a class having independent validation rules, where the validation object may return multiple reasons why a particular validation attempt failed. Validation with Independent Conditions, Multiple Reasons for Failure Consider writing a validation class for password strength enforcement - when a user is required to choose a password that meets certain criteria for helping secure user accounts. Let us assume that the password security criteria enforce that the password: is at least 8 characters in length, contains at least one uppercase letter, contains at least one lowercase letter, and contains at least one digit character. The following class implements these validation criteria: namespace MyValid; use Laminas\\Validator\\AbstractValidator; class PasswordStrength extends AbstractValidator { const LENGTH = 'length'; const UPPER = 'upper'; const LOWER = 'lower'; const DIGIT = 'digit'; protected $messageTemplates = [ self::LENGTH =&gt; \"'%value%' must be at least 8 characters in length\", self::UPPER =&gt; \"'%value%' must contain at least one uppercase letter\", self::LOWER =&gt; \"'%value%' must contain at least one lowercase letter\", self::DIGIT =&gt; \"'%value%' must contain at least one digit character\", ]; public function isValid($value) { $this-&gt;setValue($value); $isValid = true; if (strlen($value) &lt; 8) { $this-&gt;error(self::LENGTH); $isValid = false; } if (! preg_match('/[A-Z]/', $value)) { $this-&gt;error(self::UPPER); $isValid = false; } if (! preg_match('/[a-z]/', $value)) { $this-&gt;error(self::LOWER); $isValid = false; } if (! preg_match('/\\d/', $value)) { $this-&gt;error(self::DIGIT); $isValid = false; } return $isValid; } } Note that the four criteria tests in isValid() do not immediately return false . This allows the validation class to provide all of the reasons that the input password failed to meet the validation requirements. If, for example, a user were to input the string #$% as a password, isValid() would cause all four validation failure messages to be returned by a subsequent call to getMessages() .","title":"Writing Validators"},{"location":"v2/writing-validators/#writing-validators","text":"laminas-validator supplies a set of commonly needed validators, but many applications have needs for custom validators. The component allows this via implementations of Laminas\\Validator\\ValidatorInterface . Laminas\\Validator\\ValidatorInterface defines two methods: isValid() and getMessages() . An object that implements the interface may be added to a validator chain using Laminas\\Validator\\ValidatorChain::addValidator() . Such objects may also be used with laminas-inputfilter . Validators will return a boolean value from isValid() , and report information regarding why a value failed validation via getMessages() . The availability of the reasons for validation failures may be valuable to an application for various purposes, such as providing statistics for usability analysis. Basic validation failure message functionality is implemented in Laminas\\Validator\\AbstractValidator , which you may extend for your custom validators. Extending class you would implement the isValid() method logic and define the message variables and message templates that correspond to the types of validation failures that can occur. If a value fails your validation tests, then isValid() should return false . If the value passes your validation tests, then isValid() should return true . In general, the isValid() method should not throw any exceptions, except where it is impossible to determine whether or not the input value is valid. A few examples of reasonable cases for throwing an exception might be if a file cannot be opened, an LDAP server could not be contacted, or a database connection is unavailable, where such a thing may be required for validation success or failure to be determined.","title":"Writing Validators"},{"location":"v2/writing-validators/#creating-a-validation-class","text":"The following example demonstrates how a custom validator might be written. In this case, the validator tests that a value is a floating point value. namespace MyValid; use Laminas\\Validator\\AbstractValidator; class Float extends AbstractValidator { const FLOAT = 'float'; protected $messageTemplates = [ self::FLOAT =&gt; \"'%value%' is not a floating point value\", ]; public function isValid($value) { $this-&gt;setValue($value); if (! is_float($value)) { $this-&gt;error(self::FLOAT); return false; } return true; } } The class defines a template for its single validation failure message, which includes the built-in magic parameter, %value% . The call to setValue() prepares the object to insert the tested value into the failure message automatically, should the value fail validation. The call to error() tracks a reason for validation failure. Since this class only defines one failure message, it is not necessary to provide error() with the name of the failure message template.","title":"Creating a Validation Class"},{"location":"v2/writing-validators/#writing-a-validation-class-having-dependent-conditions","text":"The following example demonstrates a more complex set of validation rules: The input must be numeric. The input must fall within a range of boundary values. An input value would fail validation for exactly one of the following reasons: The input value is not numeric. The input value is less than the minimum allowed value. The input value is more than the maximum allowed value. These validation failure reasons are then translated to definitions in the class: namespace MyValid; use Laminas\\Validator\\AbstractValidator; class NumericBetween extends AbstractValidator { const MSG_NUMERIC = 'msgNumeric'; const MSG_MINIMUM = 'msgMinimum'; const MSG_MAXIMUM = 'msgMaximum'; public $minimum = 0; public $maximum = 100; protected $messageVariables = [ 'min' =&gt; 'minimum', 'max' =&gt; 'maximum', ]; protected $messageTemplates = [ self::MSG_NUMERIC =&gt; \"'%value%' is not numeric\", self::MSG_MINIMUM =&gt; \"'%value%' must be at least '%min%'\", self::MSG_MAXIMUM =&gt; \"'%value%' must be no more than '%max%'\", ]; public function isValid($value) { $this-&gt;setValue($value); if (! is_numeric($value)) { $this-&gt;error(self::MSG_NUMERIC); return false; } if ($value &lt; $this-&gt;minimum) { $this-&gt;error(self::MSG_MINIMUM); return false; } if ($value &gt; $this-&gt;maximum) { $this-&gt;error(self::MSG_MAXIMUM); return false; } return true; } } The public properties $minimum and $maximum have been established to provide the minimum and maximum boundaries, respectively, for a value to successfully validate. The class also defines two message variables that correspond to the public properties and allow min and max to be used in message templates as magic parameters, just as with value . Note that if any one of the validation checks in isValid() fails, an appropriate failure message is prepared, and the method immediately returns false . These validation rules are therefore sequentially dependent; that is, if one test should fail, there is no need to test any subsequent validation rules. This need not be the case, however. The following example illustrates how to write a class having independent validation rules, where the validation object may return multiple reasons why a particular validation attempt failed.","title":"Writing a Validation Class having Dependent Conditions"},{"location":"v2/writing-validators/#validation-with-independent-conditions-multiple-reasons-for-failure","text":"Consider writing a validation class for password strength enforcement - when a user is required to choose a password that meets certain criteria for helping secure user accounts. Let us assume that the password security criteria enforce that the password: is at least 8 characters in length, contains at least one uppercase letter, contains at least one lowercase letter, and contains at least one digit character. The following class implements these validation criteria: namespace MyValid; use Laminas\\Validator\\AbstractValidator; class PasswordStrength extends AbstractValidator { const LENGTH = 'length'; const UPPER = 'upper'; const LOWER = 'lower'; const DIGIT = 'digit'; protected $messageTemplates = [ self::LENGTH =&gt; \"'%value%' must be at least 8 characters in length\", self::UPPER =&gt; \"'%value%' must contain at least one uppercase letter\", self::LOWER =&gt; \"'%value%' must contain at least one lowercase letter\", self::DIGIT =&gt; \"'%value%' must contain at least one digit character\", ]; public function isValid($value) { $this-&gt;setValue($value); $isValid = true; if (strlen($value) &lt; 8) { $this-&gt;error(self::LENGTH); $isValid = false; } if (! preg_match('/[A-Z]/', $value)) { $this-&gt;error(self::UPPER); $isValid = false; } if (! preg_match('/[a-z]/', $value)) { $this-&gt;error(self::LOWER); $isValid = false; } if (! preg_match('/\\d/', $value)) { $this-&gt;error(self::DIGIT); $isValid = false; } return $isValid; } } Note that the four criteria tests in isValid() do not immediately return false . This allows the validation class to provide all of the reasons that the input password failed to meet the validation requirements. If, for example, a user were to input the string #$% as a password, isValid() would cause all four validation failure messages to be returned by a subsequent call to getMessages() .","title":"Validation with Independent Conditions, Multiple Reasons for Failure"},{"location":"v2/validators/barcode/","text":"Barcode Validator Laminas\\Validator\\Barcode allows you to check if a given value can be represented as a barcode. Supported barcodes Laminas\\Validator\\Barcode supports multiple barcode standards and can be extended with proprietary barcode implementations. The following barcode standards are supported: CODABAR Also known as Code-a-bar. This barcode has no length limitation. It supports only digits, and 6 special chars. Codabar is a self-checking barcode. This standard is very old. Common use cases are within airbills or photo labs where multi-part forms are used with dot-matrix printers. CODE128 CODE128 is a high density barcode. This barcode has no length limitation. It supports the first 128 ascii characters. When used with printing characters it has an checksum which is calculated modulo 103. This standard is used worldwide as it supports upper and lowercase characters. CODE25 Often called \"two of five\" or \"Code25 Industrial\". This barcode has no length limitation. It supports only digits, and the last digit can be an optional checksum which is calculated with modulo 10. This standard is very old and nowadays not often used. Common use cases are within the industry. CODE25INTERLEAVED Often called \"Code 2 of 5 Interleaved\". This standard is a variant of CODE25. It has no length limitation, but it must contain an even amount of characters. It supports only digits, and the last digit can be an optional checksum which is calculated with modulo 10. It is used worldwide and common on the market. CODE39 CODE39 is one of the oldest available codes. This barcode has a variable length. It supports digits, upper cased alphabetical characters and 7 special characters like whitespace, point and dollar sign. It can have an optional checksum which is calculated with modulo 43. This standard is used worldwide and common within the industry. CODE39EXT CODE39EXT is an extension of CODE39. This barcode has the same properties as CODE39. Additionally it allows the usage of all 128 ASCII characters. This standard is used worldwide and common within the industry. CODE93 CODE93 is the successor of CODE39. This barcode has a variable length. It supports digits, alphabetical characters and 7 special characters. It has an optional checksum which is calculated with modulo 47 and contains 2 characters. This standard produces a denser code than CODE39 and is more secure. CODE93EXT CODE93EXT is an extension of CODE93. This barcode has the same properties as CODE93. Additionally it allows the usage of all 128 ASCII characters. This standard is used worldwide and common within the industry. EAN2 EAN is the shortcut for \"European Article Number\". These barcode must have 2 characters. It supports only digits and does not have a checksum. This standard is mainly used as addition to EAN13 (ISBN) when printed on books. EAN5 EAN is the shortcut for \"European Article Number\". These barcode must have 5 characters. It supports only digits and does not have a checksum. This standard is mainly used as addition to EAN13 (ISBN) when printed on books. EAN8 EAN is the shortcut for \"European Article Number\". These barcode can have 7 or 8 characters. It supports only digits. When it has a length of 8 characters it includes a checksum. This standard is used worldwide but has a very limited range. It can be found on small articles where a longer barcode could not be printed. EAN12 EAN is the shortcut for \"European Article Number\". This barcode must have a length of 12 characters. It supports only digits, and the last digit is always a checksum which is calculated with modulo 10. This standard is used within the USA and common on the market. It has been superseded by EAN13. EAN13 EAN is the shortcut for \"European Article Number\". This barcode must have a length of 13 characters. It supports only digits, and the last digit is always a checksum which is calculated with modulo 10. This standard is used worldwide and common on the market. EAN14 EAN is the shortcut for \"European Article Number\". This barcode must have a length of 14 characters. It supports only digits, and the last digit is always a checksum which is calculated with modulo 10. This standard is used worldwide and common on the market. It is the successor for EAN13. EAN18 EAN is the shortcut for \"European Article Number\". This barcode must have a length of 18 characters. It support only digits. The last digit is always a checksum digit which is calculated with modulo 10. This code is often used for the identification of shipping containers. GTIN12 GTIN is the shortcut for \"Global Trade Item Number\". This barcode uses the same standard as EAN12 and is its successor. It's commonly used within the USA. GTIN13 GTIN is the shortcut for \"Global Trade Item Number\". This barcode uses the same standard as EAN13 and is its successor. It is used worldwide by industry. GTIN14 GTIN is the shortcut for \"Global Trade Item Number\". This barcode uses the same standard as EAN14 and is its successor. It is used worldwide and common on the market. IDENTCODE Identcode is used by Deutsche Post and DHL. It's an specialized implementation of Code25. This barcode must have a length of 12 characters. It supports only digits, and the last digit is always a checksum which is calculated with modulo 10. This standard is mainly used by the companies DP and DHL. INTELLIGENTMAIL Intelligent Mail is a postal barcode. This barcode can have a length of 20, 25, 29 or 31 characters. It supports only digits, and contains no checksum. This standard is the successor of PLANET and POSTNET. It is mainly used by the United States Postal Services. ISSN ISSN is the abbreviation for International Standard Serial Number. This barcode can have a length of 8 or 13 characters. It supports only digits, and the last digit must be a checksum digit which is calculated with modulo 11. It is used worldwide for printed publications. ITF14 ITF14 is the GS1 implementation of an Interleaved Two of Five bar code. This barcode is a special variant of Interleaved 2 of 5. It must have a length of 14 characters and is based on GTIN14. It supports only digits, and the last digit must be a checksum digit which is calculated with modulo 10. It is used worldwide and common within the market. LEITCODE Leitcode is used by Deutsche Post and DHL. It's an specialized implementation of Code25. This barcode must have a length of 14 characters. It supports only digits, and the last digit is always a checksum which is calculated with modulo 10. This standard is mainly used by the companies DP and DHL. PLANET Planet is the abbreviation for Postal Alpha Numeric Encoding Technique. This barcode can have a length of 12 or 14 characters. It supports only digits, and the last digit is always a checksum. This standard is mainly used by the United States Postal Services. POSTNET Postnet is used by the US Postal Service. This barcode can have a length of 6, 7, 10 or 12 characters. It supports only digits, and the last digit is always a checksum. This standard is mainly used by the United States Postal Services. ROYALMAIL Royalmail is used by Royal Mail. This barcode has no defined length. It supports digits, uppercase letters, and the last digit is always a checksum. This standard is mainly used by Royal Mail for their Cleanmail Service. It is also called RM4SCC. SSCC SSCC is the shortcut for \"Serial Shipping Container Code\". This barcode is a variant of EAN barcode. It must have a length of 18 characters and supports only digits. The last digit must be a checksum digit which is calculated with modulo 10. It is commonly used by the transport industry. UPCA UPC is the shortcut for \"Universal Product Code\". This barcode preceded EAN13. It must have a length of 12 characters and supports only digits. The last digit must be a checksum digit which is calculated with modulo 10. It is commonly used within the USA. UPCE UPCE is the short variant from UPCA. This barcode is a smaller variant of UPCA. It can have a length of 6, 7 or 8 characters and supports only digits. When the barcode is 8 chars long it includes a checksum which is calculated with modulo 10. It is commonly used with small products where a UPCA barcode would not fit. Supported options The following options are supported for Laminas\\Validator\\Barcode : adapter : Sets the barcode adapter which will be used. Supported are all above noted adapters. When using a self defined adapter, then you have to set the complete class name. checksum : TRUE when the barcode should contain a checksum. The default value depends on the used adapter. Note that some adapters don't allow to set this option. options : Defines optional options for a self written adapters. Basic usage To validate if a given string is a barcode you must know its type. See the following example for an EAN13 barcode: $valid = new Laminas\\Validator\\Barcode('EAN13'); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Optional checksum Some barcodes can be provided with an optional checksum. These barcodes would be valid even without checksum. Still, when you provide a checksum, then you should also validate it. By default, these barcode types perform no checksum validation. By using the checksum option you can define if the checksum will be validated or ignored. $valid = new Laminas\\Validator\\Barcode([ 'adapter' =&gt; 'EAN13', 'checksum' =&gt; false, ]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Reduced security by disabling checksum validation By switching off checksum validation you will also reduce the security of the used barcodes. Additionally you should note that you can also turn off the checksum validation for those barcode types which must contain a checksum value. Barcodes which would not be valid could then be returned as valid even if they are not. Writing custom adapters You may write custom barcode validators for usage with Laminas\\Validator\\Barcode ; this is often necessary when dealing with proprietary barcode types. To write your own barcode validator, you need the following information. Length : The length your barcode must have. It can have one of the following values: Integer : A value greater 0, which means that the barcode must have this length. -1 : There is no limitation for the length of this barcode. \"even\" : The length of this barcode must have a even amount of digits. \"odd\" : The length of this barcode must have a odd amount of digits. array : An array of integer values. The length of this barcode must have one of the set array values. Characters : A string which contains all allowed characters for this barcode. Also the integer value 128 is allowed, which means the first 128 characters of the ASCII table. Checksum : A string which will be used as callback for a method which does the checksum validation. Your custom barcode validator must extend Laminas\\Validator\\Barcode\\AbstractAdapter or implement Laminas\\Validator\\Barcode\\AdapterInterface . As an example, let's create a validator that expects an even number of characters that include all digits and the letters 'ABCDE', and which requires a checksum. namespace My\\Barcode; use Laminas\\Validator\\Barcode; use Laminas\\Validator\\Barcode\\AbstractAdapter; class MyBar extends AbstractAdapter { protected $length = 'even'; protected $characters = '0123456789ABCDE'; protected $checksum = 'mod66'; protected function mod66($barcode) { // do some validations and return a boolean } } $valid = Barcode(MyBar::class); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Barcode"},{"location":"v2/validators/barcode/#barcode-validator","text":"Laminas\\Validator\\Barcode allows you to check if a given value can be represented as a barcode.","title":"Barcode Validator"},{"location":"v2/validators/barcode/#supported-barcodes","text":"Laminas\\Validator\\Barcode supports multiple barcode standards and can be extended with proprietary barcode implementations. The following barcode standards are supported:","title":"Supported barcodes"},{"location":"v2/validators/barcode/#supported-options","text":"The following options are supported for Laminas\\Validator\\Barcode : adapter : Sets the barcode adapter which will be used. Supported are all above noted adapters. When using a self defined adapter, then you have to set the complete class name. checksum : TRUE when the barcode should contain a checksum. The default value depends on the used adapter. Note that some adapters don't allow to set this option. options : Defines optional options for a self written adapters.","title":"Supported options"},{"location":"v2/validators/barcode/#basic-usage","text":"To validate if a given string is a barcode you must know its type. See the following example for an EAN13 barcode: $valid = new Laminas\\Validator\\Barcode('EAN13'); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Basic usage"},{"location":"v2/validators/barcode/#optional-checksum","text":"Some barcodes can be provided with an optional checksum. These barcodes would be valid even without checksum. Still, when you provide a checksum, then you should also validate it. By default, these barcode types perform no checksum validation. By using the checksum option you can define if the checksum will be validated or ignored. $valid = new Laminas\\Validator\\Barcode([ 'adapter' =&gt; 'EAN13', 'checksum' =&gt; false, ]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Optional checksum"},{"location":"v2/validators/barcode/#writing-custom-adapters","text":"You may write custom barcode validators for usage with Laminas\\Validator\\Barcode ; this is often necessary when dealing with proprietary barcode types. To write your own barcode validator, you need the following information. Length : The length your barcode must have. It can have one of the following values: Integer : A value greater 0, which means that the barcode must have this length. -1 : There is no limitation for the length of this barcode. \"even\" : The length of this barcode must have a even amount of digits. \"odd\" : The length of this barcode must have a odd amount of digits. array : An array of integer values. The length of this barcode must have one of the set array values. Characters : A string which contains all allowed characters for this barcode. Also the integer value 128 is allowed, which means the first 128 characters of the ASCII table. Checksum : A string which will be used as callback for a method which does the checksum validation. Your custom barcode validator must extend Laminas\\Validator\\Barcode\\AbstractAdapter or implement Laminas\\Validator\\Barcode\\AdapterInterface . As an example, let's create a validator that expects an even number of characters that include all digits and the letters 'ABCDE', and which requires a checksum. namespace My\\Barcode; use Laminas\\Validator\\Barcode; use Laminas\\Validator\\Barcode\\AbstractAdapter; class MyBar extends AbstractAdapter { protected $length = 'even'; protected $characters = '0123456789ABCDE'; protected $checksum = 'mod66'; protected function mod66($barcode) { // do some validations and return a boolean } } $valid = Barcode(MyBar::class); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Writing custom adapters"},{"location":"v2/validators/between/","text":"Between Validator Deprecated This validator is deprecated in favour of the NumberComparison validator and the DateComparison validator for validation of dates. This validator will be removed in version 3.0. Laminas\\Validator\\Between allows you to validate if a given value is between two other values. Only supports number validation Laminas\\Validator\\Between supports only the validation of numbers. Strings or dates can not be validated with this validator. Supported options The following options are supported for Laminas\\Validator\\Between : inclusive : Defines if the validation is inclusive of the minimum and maximum border values, or exclusive. It defaults to true . max : Sets the maximum border for the validation. min : Sets the minimum border for the validation. Default behaviour Per default, this validator checks if a value is between min and max where both border values are allowed as value. $valid = new Laminas\\Validator\\Between(['min' =&gt; 0, 'max' =&gt; 10]); $value = 10; $result = $valid-&gt;isValid($value); // returns true In the above example, the result is true due to the reason that the default search is inclusive of the border values. This means in our case that any value from '0' to '10' is allowed; values like '-1' and '11' will return false . Excluding border values Sometimes it is useful to validate a value by excluding the border values. See the following example: $valid = new Laminas\\Validator\\Between([ 'min' =&gt; 0, 'max' =&gt; 10, 'inclusive' =&gt; false, ]); $value = 10; $result = $valid-&gt;isValid($value); // returns false The example above is almost identical to our first example, but we now exclue the border values; as such, the values '0' and '10' are no longer allowed and will return false .","title":"Between"},{"location":"v2/validators/between/#between-validator","text":"Deprecated This validator is deprecated in favour of the NumberComparison validator and the DateComparison validator for validation of dates. This validator will be removed in version 3.0. Laminas\\Validator\\Between allows you to validate if a given value is between two other values.","title":"Between Validator"},{"location":"v2/validators/between/#supported-options","text":"The following options are supported for Laminas\\Validator\\Between : inclusive : Defines if the validation is inclusive of the minimum and maximum border values, or exclusive. It defaults to true . max : Sets the maximum border for the validation. min : Sets the minimum border for the validation.","title":"Supported options"},{"location":"v2/validators/between/#default-behaviour","text":"Per default, this validator checks if a value is between min and max where both border values are allowed as value. $valid = new Laminas\\Validator\\Between(['min' =&gt; 0, 'max' =&gt; 10]); $value = 10; $result = $valid-&gt;isValid($value); // returns true In the above example, the result is true due to the reason that the default search is inclusive of the border values. This means in our case that any value from '0' to '10' is allowed; values like '-1' and '11' will return false .","title":"Default behaviour"},{"location":"v2/validators/between/#excluding-border-values","text":"Sometimes it is useful to validate a value by excluding the border values. See the following example: $valid = new Laminas\\Validator\\Between([ 'min' =&gt; 0, 'max' =&gt; 10, 'inclusive' =&gt; false, ]); $value = 10; $result = $valid-&gt;isValid($value); // returns false The example above is almost identical to our first example, but we now exclue the border values; as such, the values '0' and '10' are no longer allowed and will return false .","title":"Excluding border values"},{"location":"v2/validators/bic/","text":"BIC Validator Laminas\\Validator\\BusinessIdentifierCode validates if a given value could be a \"Business Identifier Code\" (BIC) as defined by ISO 9362 . A BIC is a unique identification code for financial and non-financial institutions. Supported options There are no additional supported options for the BusinessIdentifierCode validator. BIC validation BICs should be a string which length should be equal to 8 or 11. The 4 first characters can only be letters and it is used to identify a bank or an institution. The following 2 characters can only be letters too and it should be a country code assigned within ISO 3166-1 alpha-2. The only exception is the code 'XK' used for the Republic of Kosovo. The following 2 characters can be letters or digits. It is used to represent a location (like a city) The last 3 characters are optional and can be letters or digits, generally to represent a branch office. The code 'XXX' is often used to represent the AIN office when the 11 character code is used. Basic usage $validator = new Laminas\\Validator\\BusinessIdentifierCode(); if ($validator-&gt;isValid('DEUTDEFF')) { // bic appears to be valid } else { // bic is invalid; print the reasons }","title":"BIC"},{"location":"v2/validators/bic/#bic-validator","text":"Laminas\\Validator\\BusinessIdentifierCode validates if a given value could be a \"Business Identifier Code\" (BIC) as defined by ISO 9362 . A BIC is a unique identification code for financial and non-financial institutions.","title":"BIC Validator"},{"location":"v2/validators/bic/#supported-options","text":"There are no additional supported options for the BusinessIdentifierCode validator.","title":"Supported options"},{"location":"v2/validators/bic/#bic-validation","text":"BICs should be a string which length should be equal to 8 or 11. The 4 first characters can only be letters and it is used to identify a bank or an institution. The following 2 characters can only be letters too and it should be a country code assigned within ISO 3166-1 alpha-2. The only exception is the code 'XK' used for the Republic of Kosovo. The following 2 characters can be letters or digits. It is used to represent a location (like a city) The last 3 characters are optional and can be letters or digits, generally to represent a branch office. The code 'XXX' is often used to represent the AIN office when the 11 character code is used.","title":"BIC validation"},{"location":"v2/validators/bic/#basic-usage","text":"$validator = new Laminas\\Validator\\BusinessIdentifierCode(); if ($validator-&gt;isValid('DEUTDEFF')) { // bic appears to be valid } else { // bic is invalid; print the reasons }","title":"Basic usage"},{"location":"v2/validators/callback/","text":"Callback Validator Laminas\\Validator\\Callback allows you to provide a callback with which to validate a given value. Supported options The following options are supported for Laminas\\Validator\\Callback : callback : Sets the callback which will be called for the validation. callbackOptions : Sets the additional options which will be given to the validator and/or callback. throwExceptions : When true, allows exceptions thrown inside of callbacks to propagate . Basic usage The simplest use case is to pass a function as a callback. Consider the following function: function myMethod($value) { // some validation return true; } To use it within Laminas\\Validator\\Callback , pass it to the constructor $valid = new Laminas\\Validator\\Callback('myMethod'); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Usage with closures The Callback validator supports any PHP callable, including PHP closures . $valid = new Laminas\\Validator\\Callback(function($value) { // some validation return true; }); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Usage with class-based callbacks Of course it's also possible to use a class method as callback. Consider the following class definition: class MyClass { public function myMethod($value) { // some validation return true; } } To use it with the Callback validator, pass a callable using an instance of the class: $valid = new Laminas\\Validator\\Callback([new MyClass, 'myMethod']); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } You may also define a static method as a callback. Consider the following class definition and validator usage: class MyClass { public static function test($value) { // some validation return true; } } $valid = new Laminas\\Validator\\Callback([MyClass::class, 'test']); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Finally, you may define the magic method __invoke() in your class. If you do so, you can provide a class instance itself as the callback: class MyClass { public function __invoke($value) { // some validation return true; } } $valid = new Laminas\\Validator\\Callback(new MyClass()); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Adding options Laminas\\Validator\\Callback also allows the usage of options which are provided as additional arguments to the callback. Consider the following class and method definition: class MyClass { public static function myMethod($value, $option) { // some validation return true; } /** * Or, to use with contextual validation */ public static function myMethod($value, $context, $option) { // some validation return true; } } There are two ways to inform the validator of additional options: pass them in the constructor, or pass them to the setOptions() method. To pass them to the constructor, you would need to pass an array containing two keys, callback and callbackOptions : $valid = new Laminas\\Validator\\Callback([ 'callback' =&gt; [MyClass::class, 'myMethod'], 'callbackOptions' =&gt; $options, ]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Otherwise, you may pass them to the validator after instantiation: $valid = new Laminas\\Validator\\Callback([MyClass::class, 'myMethod']); $valid-&gt;setOptions($options); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } When there are additional values given to isValid() , then these values will be passed as an additional argument: $valid = new Laminas\\Validator\\Callback([MyClass::class, 'myMethod']); $valid-&gt;setOptions($options); if ($valid-&gt;isValid($input, $context)) { // input appears to be valid } else { // input is invalid } When making the call to the callback, the value to be validated will always be passed as the first argument to the callback followed by all other values given to isValid() ; all other options will follow it. The amount and type of options which can be used is not limited. Exceptions within Callbacks By default, the callback validator will catch any Exception thrown inside the callback and return false. The error message will indicate callback failure as opposed to invalid input. There is a third option throwExceptions that when true will re-throw exceptions that occur inside the callback. This is primarily useful in a development environment when you are testing callbacks and need to catch and verify exceptions thrown by your own application. For example: $callback = static function (mixed $value): bool { if ($value === true) { return true; } throw new ApplicationException('Bad news'); } $validator = new Laminas\\Validator\\Callback([ 'callback' =&gt; $callback, 'throwExceptions' =&gt; true, ]); $validator-&gt;isValid('Nope'); // An exception is thrown","title":"Callback"},{"location":"v2/validators/callback/#callback-validator","text":"Laminas\\Validator\\Callback allows you to provide a callback with which to validate a given value.","title":"Callback Validator"},{"location":"v2/validators/callback/#supported-options","text":"The following options are supported for Laminas\\Validator\\Callback : callback : Sets the callback which will be called for the validation. callbackOptions : Sets the additional options which will be given to the validator and/or callback. throwExceptions : When true, allows exceptions thrown inside of callbacks to propagate .","title":"Supported options"},{"location":"v2/validators/callback/#basic-usage","text":"The simplest use case is to pass a function as a callback. Consider the following function: function myMethod($value) { // some validation return true; } To use it within Laminas\\Validator\\Callback , pass it to the constructor $valid = new Laminas\\Validator\\Callback('myMethod'); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Basic usage"},{"location":"v2/validators/callback/#usage-with-closures","text":"The Callback validator supports any PHP callable, including PHP closures . $valid = new Laminas\\Validator\\Callback(function($value) { // some validation return true; }); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Usage with closures"},{"location":"v2/validators/callback/#usage-with-class-based-callbacks","text":"Of course it's also possible to use a class method as callback. Consider the following class definition: class MyClass { public function myMethod($value) { // some validation return true; } } To use it with the Callback validator, pass a callable using an instance of the class: $valid = new Laminas\\Validator\\Callback([new MyClass, 'myMethod']); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } You may also define a static method as a callback. Consider the following class definition and validator usage: class MyClass { public static function test($value) { // some validation return true; } } $valid = new Laminas\\Validator\\Callback([MyClass::class, 'test']); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Finally, you may define the magic method __invoke() in your class. If you do so, you can provide a class instance itself as the callback: class MyClass { public function __invoke($value) { // some validation return true; } } $valid = new Laminas\\Validator\\Callback(new MyClass()); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Usage with class-based callbacks"},{"location":"v2/validators/callback/#adding-options","text":"Laminas\\Validator\\Callback also allows the usage of options which are provided as additional arguments to the callback. Consider the following class and method definition: class MyClass { public static function myMethod($value, $option) { // some validation return true; } /** * Or, to use with contextual validation */ public static function myMethod($value, $context, $option) { // some validation return true; } } There are two ways to inform the validator of additional options: pass them in the constructor, or pass them to the setOptions() method. To pass them to the constructor, you would need to pass an array containing two keys, callback and callbackOptions : $valid = new Laminas\\Validator\\Callback([ 'callback' =&gt; [MyClass::class, 'myMethod'], 'callbackOptions' =&gt; $options, ]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Otherwise, you may pass them to the validator after instantiation: $valid = new Laminas\\Validator\\Callback([MyClass::class, 'myMethod']); $valid-&gt;setOptions($options); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } When there are additional values given to isValid() , then these values will be passed as an additional argument: $valid = new Laminas\\Validator\\Callback([MyClass::class, 'myMethod']); $valid-&gt;setOptions($options); if ($valid-&gt;isValid($input, $context)) { // input appears to be valid } else { // input is invalid } When making the call to the callback, the value to be validated will always be passed as the first argument to the callback followed by all other values given to isValid() ; all other options will follow it. The amount and type of options which can be used is not limited.","title":"Adding options"},{"location":"v2/validators/callback/#exceptions-within-callbacks","text":"By default, the callback validator will catch any Exception thrown inside the callback and return false. The error message will indicate callback failure as opposed to invalid input. There is a third option throwExceptions that when true will re-throw exceptions that occur inside the callback. This is primarily useful in a development environment when you are testing callbacks and need to catch and verify exceptions thrown by your own application. For example: $callback = static function (mixed $value): bool { if ($value === true) { return true; } throw new ApplicationException('Bad news'); } $validator = new Laminas\\Validator\\Callback([ 'callback' =&gt; $callback, 'throwExceptions' =&gt; true, ]); $validator-&gt;isValid('Nope'); // An exception is thrown","title":"Exceptions within Callbacks"},{"location":"v2/validators/credit-card/","text":"CreditCard Validator Laminas\\Validator\\CreditCard allows you to validate if a given value could be a credit card number. A credit card contains several items of metadata, including a hologram, account number, logo, expiration date, security code, and the card holder name. The algorithms for verifying the combination of metadata are only known to the issuing company, and should be verified with them for purposes of payment. However, it's often useful to know whether or not a given number actually falls within the ranges of possible numbers prior to performing such verification, and, as such, Laminas\\Validator\\CreditCard verifies that the credit card number provided is well-formed. For those cases where you have a service that can perform comprehensive verification, Laminas\\Validator\\CreditCard also provides the ability to attach a service callback to trigger once the credit card number has been deemed valid; this callback will then be triggered, and its return value will determine overall validity. The following issuing institutes are accepted: American Express China UnionPay Diners Club Card Blanche Diners Club International Diners Club US and Canada Discover Card JCB Laser Maestro MasterCard Solo Visa Visa Electron Russia Mir Invalid institutes The institutes Bankcard and Diners Club enRoute no longer exist, and are treated as invalid. Switch has been rebranded to Visa and is therefore also treated as invalid. Supported options The following options are supported for Laminas\\Validator\\CreditCard : service : A callback to an online service which will additionally be used for the validation. type : The type of credit card which will be validated. See the below list of institutes for details. Basic usage There are several credit card institutes which can be validated by Laminas\\Validator\\CreditCard . Per default, all known institutes will be accepted. See the following example: $valid = new Laminas\\Validator\\CreditCard(); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } The above example would validate against all known credit card institutes. Accepting only specific credit cards Sometimes it is necessary to accept only specific credit card institutes instead of all; e.g., when you have a webshop which accepts only Visa and American Express cards. Laminas\\Validator\\CreditCard allows you to do exactly this by limiting it to exactly these institutes. To use a limitation you can either provide specific institutes at initiation, or afterwards by using setType() . Each can take several arguments. You can provide a single institute: use Laminas\\Validator\\CreditCard; $valid = new CreditCard(CreditCard::AMERICAN_EXPRESS); When you want to allow multiple institutes, then you can provide them as array: use Laminas\\Validator\\CreditCard; $valid = new CreditCard([ CreditCard::AMERICAN_EXPRESS, CreditCard::VISA ]); And, as with all validators, you can also pass an associative array of options or an instance of Traversable . In this case you have to provide the institutes with the type array key as demostrated here: use Laminas\\Validator\\CreditCard; $valid = new CreditCard([ 'type' =&gt; [CreditCard::AMERICAN_EXPRESS] ]); You can also manipulate institutes after instantiation by using the methods setType() , addType() , and getType() . use Laminas\\Validator\\CreditCard; $valid = new CreditCard(); $valid-&gt;setType([ CreditCard::AMERICAN_EXPRESS, CreditCard::VISA ]); Default institute When no institute is given at initiation then ALL will be used, which sets all institutes at once. In this case the usage of addType() is useless because all institutes are already added. Validation using APIs As said before Laminas\\Validator\\CreditCard will only validate the credit card number. Fortunately, some institutes provide online APIs which can validate a credit card number by using algorithms which are not available to the public. Most of these services are paid services. Therefore, this check is deactivated per default. When you have access to such an API, then you can use it as an add on for Laminas\\Validator\\CreditCard and increase the security of the validation. To do so, provide a callback to invoke when generic validation has passed. This prevents the API from being called for invalid numbers, which increases the performance of the application. setService() sets a new service, and getService() returns the set service. As a configuration option, you can give the array key service at instantiatio. For details about possible options, read the Callback validator documentation . use Laminas\\Validator\\CreditCard; // Your service class class CcService { public function checkOnline($cardnumber, $types) { // some online validation } } // The validation $service = new CcService(); $valid = new CreditCard(CreditCard::VISA); $valid-&gt;setService([$service, 'checkOnline']); The callback method will be called with the credit card number as the first parameter, and the accepted types as the second parameter.","title":"CreditCard"},{"location":"v2/validators/credit-card/#creditcard-validator","text":"Laminas\\Validator\\CreditCard allows you to validate if a given value could be a credit card number. A credit card contains several items of metadata, including a hologram, account number, logo, expiration date, security code, and the card holder name. The algorithms for verifying the combination of metadata are only known to the issuing company, and should be verified with them for purposes of payment. However, it's often useful to know whether or not a given number actually falls within the ranges of possible numbers prior to performing such verification, and, as such, Laminas\\Validator\\CreditCard verifies that the credit card number provided is well-formed. For those cases where you have a service that can perform comprehensive verification, Laminas\\Validator\\CreditCard also provides the ability to attach a service callback to trigger once the credit card number has been deemed valid; this callback will then be triggered, and its return value will determine overall validity. The following issuing institutes are accepted: American Express China UnionPay Diners Club Card Blanche Diners Club International Diners Club US and Canada Discover Card JCB Laser Maestro MasterCard Solo Visa Visa Electron Russia Mir","title":"CreditCard Validator"},{"location":"v2/validators/credit-card/#supported-options","text":"The following options are supported for Laminas\\Validator\\CreditCard : service : A callback to an online service which will additionally be used for the validation. type : The type of credit card which will be validated. See the below list of institutes for details.","title":"Supported options"},{"location":"v2/validators/credit-card/#basic-usage","text":"There are several credit card institutes which can be validated by Laminas\\Validator\\CreditCard . Per default, all known institutes will be accepted. See the following example: $valid = new Laminas\\Validator\\CreditCard(); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } The above example would validate against all known credit card institutes.","title":"Basic usage"},{"location":"v2/validators/credit-card/#accepting-only-specific-credit-cards","text":"Sometimes it is necessary to accept only specific credit card institutes instead of all; e.g., when you have a webshop which accepts only Visa and American Express cards. Laminas\\Validator\\CreditCard allows you to do exactly this by limiting it to exactly these institutes. To use a limitation you can either provide specific institutes at initiation, or afterwards by using setType() . Each can take several arguments. You can provide a single institute: use Laminas\\Validator\\CreditCard; $valid = new CreditCard(CreditCard::AMERICAN_EXPRESS); When you want to allow multiple institutes, then you can provide them as array: use Laminas\\Validator\\CreditCard; $valid = new CreditCard([ CreditCard::AMERICAN_EXPRESS, CreditCard::VISA ]); And, as with all validators, you can also pass an associative array of options or an instance of Traversable . In this case you have to provide the institutes with the type array key as demostrated here: use Laminas\\Validator\\CreditCard; $valid = new CreditCard([ 'type' =&gt; [CreditCard::AMERICAN_EXPRESS] ]); You can also manipulate institutes after instantiation by using the methods setType() , addType() , and getType() . use Laminas\\Validator\\CreditCard; $valid = new CreditCard(); $valid-&gt;setType([ CreditCard::AMERICAN_EXPRESS, CreditCard::VISA ]);","title":"Accepting only specific credit cards"},{"location":"v2/validators/credit-card/#validation-using-apis","text":"As said before Laminas\\Validator\\CreditCard will only validate the credit card number. Fortunately, some institutes provide online APIs which can validate a credit card number by using algorithms which are not available to the public. Most of these services are paid services. Therefore, this check is deactivated per default. When you have access to such an API, then you can use it as an add on for Laminas\\Validator\\CreditCard and increase the security of the validation. To do so, provide a callback to invoke when generic validation has passed. This prevents the API from being called for invalid numbers, which increases the performance of the application. setService() sets a new service, and getService() returns the set service. As a configuration option, you can give the array key service at instantiatio. For details about possible options, read the Callback validator documentation . use Laminas\\Validator\\CreditCard; // Your service class class CcService { public function checkOnline($cardnumber, $types) { // some online validation } } // The validation $service = new CcService(); $valid = new CreditCard(CreditCard::VISA); $valid-&gt;setService([$service, 'checkOnline']); The callback method will be called with the credit card number as the first parameter, and the accepted types as the second parameter.","title":"Validation using APIs"},{"location":"v2/validators/csrf/","text":"CSRF Validator Deprecated This validator is deprecated in favour of the drop-in replacement validator shipped in version 2.21.0 of laminas-session . The validator here will be removed in version 3.0 of laminas-validator . Laminas\\Validator\\Csrf provides the ability to both generate and validate CSRF tokens. This allows you to validate if a form submission originated from the same site, by confirming the value of the CSRF field in the submitted form is the same as the one contained in the original form. Cross-Site Request Forgery (CSRF) is a security vector in which an unauthorized request is accepted by a server on behalf of another user; it is essentially an exploit of the trust a site places on a user's browser. The typical mitigation is to create a one-time token that is transmitted as part of the original form, and which must then be transmitted back by the client. This token expires after first submission or after a short amount of time, preventing replays or further submissions. If the token provided does not match what was originally sent, an error should be returned. Supported Options The following options are supported for Laminas\\Validator\\Csrf . Option Description Optional/Mandatory name The name of the CSRF element Optional salt The salt for the CSRF token Optional session The name of the session element containing the CSRF element Mandatory timeout The TTL for the CSRF token Optional Basic Usage Here is a basic example. // Initialise a new session container // or use the existing one in your application $session = new Laminas\\Session\\Container(); // Create the validator $validator = new Laminas\\Validator\\Csrf([ 'session' =&gt; $session, ]); $hash = $validator-&gt;getHash(); // ...Render the hash in the form. // Validate the hash after form submission. echo ($validator-&gt;isValid($hash)) ? \"Token is valid\" : \"Token is NOT valid\";","title":"Csrf"},{"location":"v2/validators/csrf/#csrf-validator","text":"Deprecated This validator is deprecated in favour of the drop-in replacement validator shipped in version 2.21.0 of laminas-session . The validator here will be removed in version 3.0 of laminas-validator . Laminas\\Validator\\Csrf provides the ability to both generate and validate CSRF tokens. This allows you to validate if a form submission originated from the same site, by confirming the value of the CSRF field in the submitted form is the same as the one contained in the original form. Cross-Site Request Forgery (CSRF) is a security vector in which an unauthorized request is accepted by a server on behalf of another user; it is essentially an exploit of the trust a site places on a user's browser. The typical mitigation is to create a one-time token that is transmitted as part of the original form, and which must then be transmitted back by the client. This token expires after first submission or after a short amount of time, preventing replays or further submissions. If the token provided does not match what was originally sent, an error should be returned.","title":"CSRF Validator"},{"location":"v2/validators/csrf/#supported-options","text":"The following options are supported for Laminas\\Validator\\Csrf . Option Description Optional/Mandatory name The name of the CSRF element Optional salt The salt for the CSRF token Optional session The name of the session element containing the CSRF element Mandatory timeout The TTL for the CSRF token Optional","title":"Supported Options"},{"location":"v2/validators/csrf/#basic-usage","text":"Here is a basic example. // Initialise a new session container // or use the existing one in your application $session = new Laminas\\Session\\Container(); // Create the validator $validator = new Laminas\\Validator\\Csrf([ 'session' =&gt; $session, ]); $hash = $validator-&gt;getHash(); // ...Render the hash in the form. // Validate the hash after form submission. echo ($validator-&gt;isValid($hash)) ? \"Token is valid\" : \"Token is NOT valid\";","title":"Basic Usage"},{"location":"v2/validators/date-comparison/","text":"Date Comparison Validator Laminas\\Validator\\DateComparison allows you to validate if a given value is a date that is either: Between two pre defined dates After a minimum date Before a maximum date By default, comparisons are inclusive. Supported Options The following options are supported for Laminas\\Validator\\DateComparison : Option Data Type Default Value Description max string\\|DateTimeInterface null Sets the upper bound for the input. min string\\|DateTimeInterface null Sets the lower bound for the input. inclusiveMin bool true Defines if the validation is inclusive of the lower bound, or exclusive. inclusiveMax bool true Defines if the validation is inclusive of the upper bound, or exclusive. inputFormat string null Defines the expected date format if required. Min and Max Date Options The min and max options when set must be one of the following: An object that implements DateTimeInterface A date string in ISO format, YYYY-MM-DD , i.e. '2020-01-31' A date and time string in W3C format, YYYY-MM-DDTHH:MM:SS , i.e. '2020-01-31T12:34:56' At least one of min , max or both must be provided as an option or an exception will be thrown. It doesn't make sense to use this validator without specifying the boundaries to compare the input to. Default Behaviour Per default, this validator checks if a value is between min and max where both upper and lower bounds are considered valid. $valid = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', 'max' =&gt; '2020-12-31', ]); $value = '2020-01-01'; $result = $valid-&gt;isValid($value); // returns true In the above example, the result is true due to the reason that the default search is inclusive of the border values. This means in our case that any date between '1st January 2020' to '31st December 2020' is allowed; any other valid date will return false . Min and Max Behaviour In order to validate a date that is after than a lower bound, either omit the max option, or set it explicitly to null : $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', 'max' =&gt; null, ]); $validator-&gt;isValid('2020-02-03'); // true Conversely, to ensure a date is prior to an upper bound, omit the min option or explicitly set it to null : $validator = new Laminas\\Validator\\DateComparison(['max' =&gt; '2020-12-31']); $validator-&gt;isValid('2024-06-07'); // false Validity of Date Inputs In order to compare dates correctly, the validator converts the input to a DateTimeInterface object, therefore, it must be possible to parse string input as a valid date. Because it is likely that the validator will be paired with some kind of web form, known formats returned by &lt;input type=\"datetime-local\"&gt; or &lt;input type=\"date\"&gt; are always supported without further configuration. For example: $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', ]); $validator-&gt;isValid('2020-03-04'); // true $validator-&gt;isValid('2020-01-01T12:34:56'); // true If you have inputs in your application where you expect dates to be provided in a different format such as l jS F Y , you can use the inputFormat option to specify this: $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', 'inputFormat' =&gt; 'l jS F Y', ]); $validator-&gt;isValid('Wednesday 1st January 2020'); // true Time Zones Time zones for the min and max options, and for the validated value are discarded and all dates are compared as UTC date-times. $africa = new DateTimeZone('Africa/Johannesburg'); $lower = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2020-01-01 10:00:00', $africa); $upper = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2020-01-01 12:00:00', $africa); $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; $lower, 'max' =&gt; $upper, ]); $usa = new DateTimeZone('America/New_York'); $input = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2020-01-01 10:45:00', $usa); $validator-&gt;isValid($input); // true In the above example, the validated value is considered as 2020-01-01 10:45:00 in any timezone, and it is between the lower bound of 2020-01-01 10:00:00 and the upper bound of 2020-01-01 12:00:00","title":"DateComparison"},{"location":"v2/validators/date-comparison/#date-comparison-validator","text":"Laminas\\Validator\\DateComparison allows you to validate if a given value is a date that is either: Between two pre defined dates After a minimum date Before a maximum date By default, comparisons are inclusive.","title":"Date Comparison Validator"},{"location":"v2/validators/date-comparison/#supported-options","text":"The following options are supported for Laminas\\Validator\\DateComparison : Option Data Type Default Value Description max string\\|DateTimeInterface null Sets the upper bound for the input. min string\\|DateTimeInterface null Sets the lower bound for the input. inclusiveMin bool true Defines if the validation is inclusive of the lower bound, or exclusive. inclusiveMax bool true Defines if the validation is inclusive of the upper bound, or exclusive. inputFormat string null Defines the expected date format if required.","title":"Supported Options"},{"location":"v2/validators/date-comparison/#min-and-max-date-options","text":"The min and max options when set must be one of the following: An object that implements DateTimeInterface A date string in ISO format, YYYY-MM-DD , i.e. '2020-01-31' A date and time string in W3C format, YYYY-MM-DDTHH:MM:SS , i.e. '2020-01-31T12:34:56' At least one of min , max or both must be provided as an option or an exception will be thrown. It doesn't make sense to use this validator without specifying the boundaries to compare the input to.","title":"Min and Max Date Options"},{"location":"v2/validators/date-comparison/#default-behaviour","text":"Per default, this validator checks if a value is between min and max where both upper and lower bounds are considered valid. $valid = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', 'max' =&gt; '2020-12-31', ]); $value = '2020-01-01'; $result = $valid-&gt;isValid($value); // returns true In the above example, the result is true due to the reason that the default search is inclusive of the border values. This means in our case that any date between '1st January 2020' to '31st December 2020' is allowed; any other valid date will return false .","title":"Default Behaviour"},{"location":"v2/validators/date-comparison/#min-and-max-behaviour","text":"In order to validate a date that is after than a lower bound, either omit the max option, or set it explicitly to null : $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', 'max' =&gt; null, ]); $validator-&gt;isValid('2020-02-03'); // true Conversely, to ensure a date is prior to an upper bound, omit the min option or explicitly set it to null : $validator = new Laminas\\Validator\\DateComparison(['max' =&gt; '2020-12-31']); $validator-&gt;isValid('2024-06-07'); // false","title":"Min and Max Behaviour"},{"location":"v2/validators/date-comparison/#validity-of-date-inputs","text":"In order to compare dates correctly, the validator converts the input to a DateTimeInterface object, therefore, it must be possible to parse string input as a valid date. Because it is likely that the validator will be paired with some kind of web form, known formats returned by &lt;input type=\"datetime-local\"&gt; or &lt;input type=\"date\"&gt; are always supported without further configuration. For example: $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', ]); $validator-&gt;isValid('2020-03-04'); // true $validator-&gt;isValid('2020-01-01T12:34:56'); // true If you have inputs in your application where you expect dates to be provided in a different format such as l jS F Y , you can use the inputFormat option to specify this: $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; '2020-01-01', 'inputFormat' =&gt; 'l jS F Y', ]); $validator-&gt;isValid('Wednesday 1st January 2020'); // true","title":"Validity of Date Inputs"},{"location":"v2/validators/date-comparison/#time-zones","text":"Time zones for the min and max options, and for the validated value are discarded and all dates are compared as UTC date-times. $africa = new DateTimeZone('Africa/Johannesburg'); $lower = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2020-01-01 10:00:00', $africa); $upper = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2020-01-01 12:00:00', $africa); $validator = new Laminas\\Validator\\DateComparison([ 'min' =&gt; $lower, 'max' =&gt; $upper, ]); $usa = new DateTimeZone('America/New_York'); $input = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', '2020-01-01 10:45:00', $usa); $validator-&gt;isValid($input); // true In the above example, the validated value is considered as 2020-01-01 10:45:00 in any timezone, and it is between the lower bound of 2020-01-01 10:00:00 and the upper bound of 2020-01-01 12:00:00","title":"Time Zones"},{"location":"v2/validators/date/","text":"Date Validator Laminas\\Validator\\Date allows you to validate if a given value contains a date. Supported options The following options are supported for Laminas\\Validator\\Date : format : Sets the format which is used to write the date. locale : Sets the locale which will be used to validate date values. Default date validation The easiest way to validate a date is by using the default date format, Y-m-d . $validator = new Laminas\\Validator\\Date(); $validator-&gt;isValid('2000-10-10'); // returns true $validator-&gt;isValid('10.10.2000'); // returns false Specifying a date format Laminas\\Validator\\Date also supports custom date formats. When you want to validate such a date, use the format option. This option accepts any format allowed by the PHP DateTime::createFromFormat() method. $validator = new Laminas\\Validator\\Date(['format' =&gt; 'Y']); $validator-&gt;isValid('2010'); // returns true $validator-&gt;isValid('May'); // returns false Strict mode Since 2.13.0 By default, Laminas\\Validator\\Date only validates that it can convert the provided value to a valid DateTime value. If you want to require that the date is specified in a specific format, you can provide both the date format and the strict options. In such a scenario, the value must both be covertable to a DateTime value and be in the same format as provided to the validator. (Generally, this will mean the value must be a string.) $validator = new Laminas\\Validator\\Date(['format' =&gt; 'Y-m-d', 'strict' =&gt; true]); $validator-&gt;isValid('2010-10-10'); // returns true $validator-&gt;isValid(new DateTime('2010-10-10')); // returns false; value is not a string $validator-&gt;isValid('2010.10.10'); // returns false; format differs","title":"Date"},{"location":"v2/validators/date/#date-validator","text":"Laminas\\Validator\\Date allows you to validate if a given value contains a date.","title":"Date Validator"},{"location":"v2/validators/date/#supported-options","text":"The following options are supported for Laminas\\Validator\\Date : format : Sets the format which is used to write the date. locale : Sets the locale which will be used to validate date values.","title":"Supported options"},{"location":"v2/validators/date/#default-date-validation","text":"The easiest way to validate a date is by using the default date format, Y-m-d . $validator = new Laminas\\Validator\\Date(); $validator-&gt;isValid('2000-10-10'); // returns true $validator-&gt;isValid('10.10.2000'); // returns false","title":"Default date validation"},{"location":"v2/validators/date/#specifying-a-date-format","text":"Laminas\\Validator\\Date also supports custom date formats. When you want to validate such a date, use the format option. This option accepts any format allowed by the PHP DateTime::createFromFormat() method. $validator = new Laminas\\Validator\\Date(['format' =&gt; 'Y']); $validator-&gt;isValid('2010'); // returns true $validator-&gt;isValid('May'); // returns false","title":"Specifying a date format"},{"location":"v2/validators/date/#strict-mode","text":"Since 2.13.0 By default, Laminas\\Validator\\Date only validates that it can convert the provided value to a valid DateTime value. If you want to require that the date is specified in a specific format, you can provide both the date format and the strict options. In such a scenario, the value must both be covertable to a DateTime value and be in the same format as provided to the validator. (Generally, this will mean the value must be a string.) $validator = new Laminas\\Validator\\Date(['format' =&gt; 'Y-m-d', 'strict' =&gt; true]); $validator-&gt;isValid('2010-10-10'); // returns true $validator-&gt;isValid(new DateTime('2010-10-10')); // returns false; value is not a string $validator-&gt;isValid('2010.10.10'); // returns false; format differs","title":"Strict mode"},{"location":"v2/validators/db/","text":"Db\\RecordExists and Db\\NoRecordExists Validators Laminas\\Validator\\Db\\RecordExists and Laminas\\Validator\\Db\\NoRecordExists provide a means to test whether a record exists in a given table of a database, with a given value. Deprecated laminas-db has been marked as security only since July 2022 , as such, these validators have been deprecated for removal in version 3.0 of laminas-validator Installation requirements Laminas\\Validator\\Db\\NoRecordExists and Laminas\\Validator\\Db\\RecordExists depends on the laminas-db component, so be sure to have it installed before getting started: $ composer require laminas/laminas-db Supported options The following options are supported for Laminas\\Validator\\Db\\NoRecordExists and Laminas\\Validator\\Db\\RecordExists : adapter : The database adapter that will be used for the search. exclude : Sets records that will be excluded from the search. field : The database field within this table that will be searched for the record. schema : Sets the schema that will be used for the search. table : The table that will be searched for the record. Basic usage An example of basic usage of the validators: // Check that the email address exists in the database $validator = new Laminas\\Validator\\Db\\RecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'emailaddress', 'adapter' =&gt; $dbAdapter, ]); if ($validator-&gt;isValid($emailaddress)) { // email address appears to be valid } else { // email address is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } The above will test that a given email address is in the database table. If no record is found containing the value of $emailaddress in the specified column, then an error message is displayed. // Check that the username is not present in the database $validator = new Laminas\\Validator\\Db\\NoRecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'username', 'adapter' =&gt; $dbAdapter, ]); if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above will test that a given username is not in the database table. If a record is found containing the value of $username in the specified column, then an error message is displayed. Excluding records Laminas\\Validator\\Db\\RecordExists and Laminas\\Validator\\Db\\NoRecordExists also provide a means to test the database, excluding a part of the table, either by providing a WHERE clause as a string, or an array with the keys field and value . When providing an array for the exclude clause, the != operator is used, so you can check the rest of a table for a value before altering a record (for example on a user profile form) // Check no other users have the username $user_id = $user-&gt;getId(); $validator = new Laminas\\Validator\\Db\\NoRecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'username', 'exclude' =&gt; [ 'field' =&gt; 'id', 'value' =&gt; $user_id, ], ]); if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above example will check the table to ensure no records other than the one where id = $user_id contains the value $username . You can also provide a string to the exclude clause so you can use an operator other than != . This can be useful for testing against composite keys. $email = 'user@example.com'; $clause = $dbAdapter-&gt;quoteIdentifier('email') . ' = ' . $dbAdapter-&gt;quoteValue($email); $validator = new Laminas\\Validator\\Db\\RecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'username', 'adapter' =&gt; $dbAdapter, 'exclude' =&gt; $clause, ]); if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above example will check the users table to ensure that only a record with both the username $username and with the email $email is valid. Database Schemas You can specify a schema within your database for adapters such as PostgreSQL and DB/2 by supplying an array with table and schema keys, as demonstrated below: $validator = new Laminas\\Validator\\Db\\RecordExists([ 'table' =&gt; 'users', 'schema' =&gt; 'my', 'field' =&gt; 'id', ]); Using a Select object It is also possible to supply the validators with a Laminas\\Db\\Sql\\Select object in place of options. The validator then uses this object instead of building its own. This allows for greater flexibility with selection of records used for validation. use Laminas\\Db\\Sql\\Select; use Laminas\\Validator\\Db\\RecordExists; $select = new Select(); $select -&gt;from('users') -&gt;where -&gt;equalTo('id', $user_id) -&gt;equalTo('email', $email); $validator = new RecordExists($select); // We still need to set our database adapter $validator-&gt;setAdapter($dbAdapter); // Validation is then performed as usual if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above example will check the users table to ensure that only a record with both the username $username and with the email $email is valid.","title":"Db\\RecordExists and Db\\NoRecordExists"},{"location":"v2/validators/db/#dbrecordexists-and-dbnorecordexists-validators","text":"Laminas\\Validator\\Db\\RecordExists and Laminas\\Validator\\Db\\NoRecordExists provide a means to test whether a record exists in a given table of a database, with a given value.","title":"Db\\RecordExists and Db\\NoRecordExists Validators"},{"location":"v2/validators/db/#deprecated","text":"laminas-db has been marked as security only since July 2022 , as such, these validators have been deprecated for removal in version 3.0 of laminas-validator","title":"Deprecated"},{"location":"v2/validators/db/#installation-requirements","text":"Laminas\\Validator\\Db\\NoRecordExists and Laminas\\Validator\\Db\\RecordExists depends on the laminas-db component, so be sure to have it installed before getting started: $ composer require laminas/laminas-db","title":"Installation requirements"},{"location":"v2/validators/db/#supported-options","text":"The following options are supported for Laminas\\Validator\\Db\\NoRecordExists and Laminas\\Validator\\Db\\RecordExists : adapter : The database adapter that will be used for the search. exclude : Sets records that will be excluded from the search. field : The database field within this table that will be searched for the record. schema : Sets the schema that will be used for the search. table : The table that will be searched for the record.","title":"Supported options"},{"location":"v2/validators/db/#basic-usage","text":"An example of basic usage of the validators: // Check that the email address exists in the database $validator = new Laminas\\Validator\\Db\\RecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'emailaddress', 'adapter' =&gt; $dbAdapter, ]); if ($validator-&gt;isValid($emailaddress)) { // email address appears to be valid } else { // email address is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } The above will test that a given email address is in the database table. If no record is found containing the value of $emailaddress in the specified column, then an error message is displayed. // Check that the username is not present in the database $validator = new Laminas\\Validator\\Db\\NoRecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'username', 'adapter' =&gt; $dbAdapter, ]); if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above will test that a given username is not in the database table. If a record is found containing the value of $username in the specified column, then an error message is displayed.","title":"Basic usage"},{"location":"v2/validators/db/#excluding-records","text":"Laminas\\Validator\\Db\\RecordExists and Laminas\\Validator\\Db\\NoRecordExists also provide a means to test the database, excluding a part of the table, either by providing a WHERE clause as a string, or an array with the keys field and value . When providing an array for the exclude clause, the != operator is used, so you can check the rest of a table for a value before altering a record (for example on a user profile form) // Check no other users have the username $user_id = $user-&gt;getId(); $validator = new Laminas\\Validator\\Db\\NoRecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'username', 'exclude' =&gt; [ 'field' =&gt; 'id', 'value' =&gt; $user_id, ], ]); if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above example will check the table to ensure no records other than the one where id = $user_id contains the value $username . You can also provide a string to the exclude clause so you can use an operator other than != . This can be useful for testing against composite keys. $email = 'user@example.com'; $clause = $dbAdapter-&gt;quoteIdentifier('email') . ' = ' . $dbAdapter-&gt;quoteValue($email); $validator = new Laminas\\Validator\\Db\\RecordExists([ 'table' =&gt; 'users', 'field' =&gt; 'username', 'adapter' =&gt; $dbAdapter, 'exclude' =&gt; $clause, ]); if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above example will check the users table to ensure that only a record with both the username $username and with the email $email is valid.","title":"Excluding records"},{"location":"v2/validators/db/#database-schemas","text":"You can specify a schema within your database for adapters such as PostgreSQL and DB/2 by supplying an array with table and schema keys, as demonstrated below: $validator = new Laminas\\Validator\\Db\\RecordExists([ 'table' =&gt; 'users', 'schema' =&gt; 'my', 'field' =&gt; 'id', ]);","title":"Database Schemas"},{"location":"v2/validators/db/#using-a-select-object","text":"It is also possible to supply the validators with a Laminas\\Db\\Sql\\Select object in place of options. The validator then uses this object instead of building its own. This allows for greater flexibility with selection of records used for validation. use Laminas\\Db\\Sql\\Select; use Laminas\\Validator\\Db\\RecordExists; $select = new Select(); $select -&gt;from('users') -&gt;where -&gt;equalTo('id', $user_id) -&gt;equalTo('email', $email); $validator = new RecordExists($select); // We still need to set our database adapter $validator-&gt;setAdapter($dbAdapter); // Validation is then performed as usual if ($validator-&gt;isValid($username)) { // username appears to be valid } else { // username is invalid; print the reason $messages = $validator-&gt;getMessages(); foreach ($messages as $message) { echo \"$message\\n\"; } } The above example will check the users table to ensure that only a record with both the username $username and with the email $email is valid.","title":"Using a Select object"},{"location":"v2/validators/digits/","text":"Digits Validator Laminas\\Validator\\Digits validates if a given value contains only digits. Installation requirements Laminas\\Validator\\Digits depends on the laminas-filter component, so be sure to have it installed before getting started: $ composer require laminas/laminas-filter Supported options There are no additional options for Laminas\\Validator\\Digits : Validating digits To validate if a given value contains only digits and no other characters, call the validator as shown below: $validator = new Laminas\\Validator\\Digits(); $validator-&gt;isValid(\"1234567890\"); // returns true $validator-&gt;isValid(1234); // returns true $validator-&gt;isValid('1a234'); // returns false Validating numbers When you want to validate numbers or numeric values, be aware that this validator only validates digits . This means that any other sign like a thousand separator or a comma will not pass this validator. In this case you should use Laminas\\I18n\\Validator\\IsInt or Laminas\\I18n\\Validator\\IsFloat .","title":"Digits"},{"location":"v2/validators/digits/#digits-validator","text":"Laminas\\Validator\\Digits validates if a given value contains only digits.","title":"Digits Validator"},{"location":"v2/validators/digits/#supported-options","text":"There are no additional options for Laminas\\Validator\\Digits :","title":"Supported options"},{"location":"v2/validators/digits/#validating-digits","text":"To validate if a given value contains only digits and no other characters, call the validator as shown below: $validator = new Laminas\\Validator\\Digits(); $validator-&gt;isValid(\"1234567890\"); // returns true $validator-&gt;isValid(1234); // returns true $validator-&gt;isValid('1a234'); // returns false","title":"Validating digits"},{"location":"v2/validators/email-address/","text":"EmailAddress Validator Laminas\\Validator\\EmailAddress allows you to validate an email address. The validator first splits the email address on local-part @ hostname and attempts to match these against known specifications for email addresses and hostnames. Basic usage A basic example of usage is below: $validator = new Laminas\\Validator\\EmailAddress(); if ($validator-&gt;isValid($email)) { // email appears to be valid } else { // email is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } This will match the email address $email and on failure populate getMessages() with useful error messages. Supported Options Laminas\\Validator\\EmailAddress supports several options which can either be set at instantiation, by giving an array with the related options, or afterwards, by using setOptions() . The following options are supported: allow : Defines which type of domain names are accepted. This option is used in conjunction with the hostnameValidator option to set the hostname validator. Possible values of this option defined in Hostname validator's ALLOW_* constants: ALLOW_DNS (default) - Allows Internet domain names (e.g. example.com) ALLOW_IP - Allows IP addresses (e.g. 192.168.0.1) ALLOW_LOCAL - Allows local network such as localhost or www.localdomain ALLOW_URI - Allows hostnames in URI generic syntax. See RFC 3986 ALLOW_ALL - Allows all types of hostnames useDeepMxCheck : Defines if the servers MX records should be verified by a deep check. When this option is set to true then additionally to MX records also the A , A6 and AAAA records are used to verify if the server accepts emails. This option defaults to false . useDomainCheck : Defines if the domain part should be checked. When this option is set to false , then only the local part of the email address will be checked. In this case the hostname validator will not be called. This option defaults to true . hostnameValidator : Sets the hostname validator object instance with which the domain part of the email address will be validated. useMxCheck : Defines if the MX records from the server should be detected. If this option is defined to true then the MX records are used to verify if the server accepts emails. This option defaults to false . Complex local parts Laminas\\Validator\\EmailAddress will match any valid email address according to RFC2822. For example, valid emails include bob@domain.com , bob+jones@domain.us , \"bob@jones\"@domain.com* and \"bob jones\"@domain.com Some obsolete email formats will not currently validate (e.g. carriage returns or a \\\\ character in an email address). Validating only the local part If you need Laminas\\Validator\\EmailAddress to check only the local part of an email address, and want to disable validation of the hostname, you can set the domain option to false . This forces Laminas\\Validator\\EmailAddress not to validate the hostname part of the email address. $validator = new Laminas\\Validator\\EmailAddress(); $validator-&gt;setOptions(['domain' =&gt; FALSE]); Validating different types of hostnames The hostname part of an email address is validated against the Hostname validator . By default only DNS hostnames of the form domain.com are accepted, though if you wish you can accept IP addresses and Local hostnames too. To do this you need to instantiate Laminas\\Validator\\EmailAddress passing a parameter to indicate the type of hostnames you want to accept. More details are included in Laminas\\Validator\\Hostname , though an example of how to accept both DNS and Local hostnames appears below: use Laminas\\Validator\\EmailAddress; use Laminas\\Validator\\Hostname; $validator = new EmailAddress( Hostname::ALLOW_DNS | Hostname::ALLOW_LOCAL); if ($validator-&gt;isValid($email)) { // email appears to be valid } else { // email is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } Checking if the hostname actually accepts email Just because an email address is in the correct format, it doesn't necessarily mean that email address actually exists. To help solve this problem, you can use MX validation to check whether an MX (email) entry exists in the DNS record for the email's hostname. This tells you that the hostname accepts email, but doesn't tell you the exact email address itself is valid. MX checking is not enabled by default. To enable MX checking you can pass a second parameter to the Laminas\\Validator\\EmailAddress constructor. $validator = new Laminas\\Validator\\EmailAddress([ 'allow' =&gt; Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' =&gt; true, ]); Alternatively you can either pass true or false to setValidateMx() to enable or disable MX validation. By enabling this setting, network functions will be used to check for the presence of an MX record on the hostname of the email address you wish to validate. Please be aware this will likely slow your script down. Sometimes validation for MX records returns false , even if emails are accepted. The reason behind this behaviour is, that servers can accept emails even if they do not provide a MX record. In this case they can provide A , A6 , or AAAA records. To allow Laminas\\Validator\\EmailAddress to check also for these other records, you need to set deep MX validation. This can be done at initiation by setting the deep option or by using setOptions() . $validator = new Laminas\\Validator\\EmailAddress([ 'allow' =&gt; Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' =&gt; true, 'useDeepMxCheck' =&gt; true, ]); Sometimes it can be useful to get the server's MX information which have been used to do further processing. Simply use getMXRecord() after validation. This method returns the received MX record including weight and sorted by it. Performance warning** You should be aware that enabling MX check will slow down you script because of the used network functions. Enabling deep check will slow down your script even more as it searches the given server for 3 additional types. Disallowed IP addresses You should note that MX validation is only accepted for external servers. When deep MX validation is enabled, then local IP addresses like 192.168.* or 169.254.* are not accepted. Validating International Domains Names Laminas\\Validator\\EmailAddress will also match international characters that exist in some domains. This is known as International Domain Name (IDN) support. This is enabled by default, though you can disable this by changing the setting via the internal Laminas\\Validator\\Hostname object that exists within Laminas\\Validator\\EmailAddress . $validator-&gt;getHostnameValidator()-&gt;setValidateIdn(false); More information on the usage of setValidateIdn() appears in the Hostname documentation . Please note IDNs are only validated if you allow DNS hostnames to be validated. Validating Top Level Domains By default a hostname will be checked against a list of known TLDs. This is enabled by default, though you can disable this by changing the setting via the internal Laminas\\Validator\\Hostname object that exists within Laminas\\Validator\\EmailAddress . $validator-&gt;getHostnameValidator()-&gt;setValidateTld(false); More information on the usage of setValidateTld() appears in the Hostname documentation . Please note TLDs are only validated if you allow DNS hostnames to be validated. Setting messages Laminas\\Validator\\EmailAddress makes also use of Laminas\\Validator\\Hostname to check the hostname part of a given email address. You can specify messages for Laminas\\Validator\\Hostname from within Laminas\\Validator\\EmailAddress . $validator = new Laminas\\Validator\\EmailAddress(); $validator-&gt;setMessages([ Laminas\\Validator\\Hostname::UNKNOWN_TLD =&gt; 'I don\\'t know the TLD you gave' ]);","title":"EmailAddress"},{"location":"v2/validators/email-address/#emailaddress-validator","text":"Laminas\\Validator\\EmailAddress allows you to validate an email address. The validator first splits the email address on local-part @ hostname and attempts to match these against known specifications for email addresses and hostnames.","title":"EmailAddress Validator"},{"location":"v2/validators/email-address/#basic-usage","text":"A basic example of usage is below: $validator = new Laminas\\Validator\\EmailAddress(); if ($validator-&gt;isValid($email)) { // email appears to be valid } else { // email is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } This will match the email address $email and on failure populate getMessages() with useful error messages.","title":"Basic usage"},{"location":"v2/validators/email-address/#supported-options","text":"Laminas\\Validator\\EmailAddress supports several options which can either be set at instantiation, by giving an array with the related options, or afterwards, by using setOptions() . The following options are supported: allow : Defines which type of domain names are accepted. This option is used in conjunction with the hostnameValidator option to set the hostname validator. Possible values of this option defined in Hostname validator's ALLOW_* constants: ALLOW_DNS (default) - Allows Internet domain names (e.g. example.com) ALLOW_IP - Allows IP addresses (e.g. 192.168.0.1) ALLOW_LOCAL - Allows local network such as localhost or www.localdomain ALLOW_URI - Allows hostnames in URI generic syntax. See RFC 3986 ALLOW_ALL - Allows all types of hostnames useDeepMxCheck : Defines if the servers MX records should be verified by a deep check. When this option is set to true then additionally to MX records also the A , A6 and AAAA records are used to verify if the server accepts emails. This option defaults to false . useDomainCheck : Defines if the domain part should be checked. When this option is set to false , then only the local part of the email address will be checked. In this case the hostname validator will not be called. This option defaults to true . hostnameValidator : Sets the hostname validator object instance with which the domain part of the email address will be validated. useMxCheck : Defines if the MX records from the server should be detected. If this option is defined to true then the MX records are used to verify if the server accepts emails. This option defaults to false .","title":"Supported Options"},{"location":"v2/validators/email-address/#complex-local-parts","text":"Laminas\\Validator\\EmailAddress will match any valid email address according to RFC2822. For example, valid emails include bob@domain.com , bob+jones@domain.us , \"bob@jones\"@domain.com* and \"bob jones\"@domain.com Some obsolete email formats will not currently validate (e.g. carriage returns or a \\\\ character in an email address).","title":"Complex local parts"},{"location":"v2/validators/email-address/#validating-only-the-local-part","text":"If you need Laminas\\Validator\\EmailAddress to check only the local part of an email address, and want to disable validation of the hostname, you can set the domain option to false . This forces Laminas\\Validator\\EmailAddress not to validate the hostname part of the email address. $validator = new Laminas\\Validator\\EmailAddress(); $validator-&gt;setOptions(['domain' =&gt; FALSE]);","title":"Validating only the local part"},{"location":"v2/validators/email-address/#validating-different-types-of-hostnames","text":"The hostname part of an email address is validated against the Hostname validator . By default only DNS hostnames of the form domain.com are accepted, though if you wish you can accept IP addresses and Local hostnames too. To do this you need to instantiate Laminas\\Validator\\EmailAddress passing a parameter to indicate the type of hostnames you want to accept. More details are included in Laminas\\Validator\\Hostname , though an example of how to accept both DNS and Local hostnames appears below: use Laminas\\Validator\\EmailAddress; use Laminas\\Validator\\Hostname; $validator = new EmailAddress( Hostname::ALLOW_DNS | Hostname::ALLOW_LOCAL); if ($validator-&gt;isValid($email)) { // email appears to be valid } else { // email is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } }","title":"Validating different types of hostnames"},{"location":"v2/validators/email-address/#checking-if-the-hostname-actually-accepts-email","text":"Just because an email address is in the correct format, it doesn't necessarily mean that email address actually exists. To help solve this problem, you can use MX validation to check whether an MX (email) entry exists in the DNS record for the email's hostname. This tells you that the hostname accepts email, but doesn't tell you the exact email address itself is valid. MX checking is not enabled by default. To enable MX checking you can pass a second parameter to the Laminas\\Validator\\EmailAddress constructor. $validator = new Laminas\\Validator\\EmailAddress([ 'allow' =&gt; Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' =&gt; true, ]); Alternatively you can either pass true or false to setValidateMx() to enable or disable MX validation. By enabling this setting, network functions will be used to check for the presence of an MX record on the hostname of the email address you wish to validate. Please be aware this will likely slow your script down. Sometimes validation for MX records returns false , even if emails are accepted. The reason behind this behaviour is, that servers can accept emails even if they do not provide a MX record. In this case they can provide A , A6 , or AAAA records. To allow Laminas\\Validator\\EmailAddress to check also for these other records, you need to set deep MX validation. This can be done at initiation by setting the deep option or by using setOptions() . $validator = new Laminas\\Validator\\EmailAddress([ 'allow' =&gt; Laminas\\Validator\\Hostname::ALLOW_DNS, 'useMxCheck' =&gt; true, 'useDeepMxCheck' =&gt; true, ]); Sometimes it can be useful to get the server's MX information which have been used to do further processing. Simply use getMXRecord() after validation. This method returns the received MX record including weight and sorted by it.","title":"Checking if the hostname actually accepts email"},{"location":"v2/validators/email-address/#validating-international-domains-names","text":"Laminas\\Validator\\EmailAddress will also match international characters that exist in some domains. This is known as International Domain Name (IDN) support. This is enabled by default, though you can disable this by changing the setting via the internal Laminas\\Validator\\Hostname object that exists within Laminas\\Validator\\EmailAddress . $validator-&gt;getHostnameValidator()-&gt;setValidateIdn(false); More information on the usage of setValidateIdn() appears in the Hostname documentation . Please note IDNs are only validated if you allow DNS hostnames to be validated.","title":"Validating International Domains Names"},{"location":"v2/validators/email-address/#validating-top-level-domains","text":"By default a hostname will be checked against a list of known TLDs. This is enabled by default, though you can disable this by changing the setting via the internal Laminas\\Validator\\Hostname object that exists within Laminas\\Validator\\EmailAddress . $validator-&gt;getHostnameValidator()-&gt;setValidateTld(false); More information on the usage of setValidateTld() appears in the Hostname documentation . Please note TLDs are only validated if you allow DNS hostnames to be validated.","title":"Validating Top Level Domains"},{"location":"v2/validators/email-address/#setting-messages","text":"Laminas\\Validator\\EmailAddress makes also use of Laminas\\Validator\\Hostname to check the hostname part of a given email address. You can specify messages for Laminas\\Validator\\Hostname from within Laminas\\Validator\\EmailAddress . $validator = new Laminas\\Validator\\EmailAddress(); $validator-&gt;setMessages([ Laminas\\Validator\\Hostname::UNKNOWN_TLD =&gt; 'I don\\'t know the TLD you gave' ]);","title":"Setting messages"},{"location":"v2/validators/explode/","text":"Explode Validator Laminas\\Validator\\Explode executes a validator for each item exploded from an array. Supported options The following options are supported for Laminas\\Validator\\Explode : valueDelimiter : Defines the delimiter used to explode values from an array. It defaults to , . If the given value is an array, this option isn't used. validator : Sets the validator that will be executed on each exploded item. This may be a validator instance, or a validator service name. Basic usage To validate if every item in an array is in a specified haystack: $inArrayValidator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; [1, 2, 3, 4, 5, 6], ]); $explodeValidator = new Laminas\\Validator\\Explode([ 'validator' =&gt; $inArrayValidator ]); $explodeValidator-&gt;isValid([1, 4, 6]); // returns true $explodeValidator-&gt;isValid([1, 4, 6, 8]); // returns false Exploding strings To validate if every e-mail in a string is contained in a list of names: $inEmailListValidator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['joseph@test.com', 'mark@test.com', 'lucia@test.com'], ]); $explodeValidator = new Laminas\\Validator\\Explode([ 'validator' =&gt; $inEmailListValidator, 'valueDelimiter' =&gt; ',' ]); $explodeValidator-&gt;isValid('joseph@test.com,mark@test.com'); // returns true $explodeValidator-&gt;isValid('lucia@test.com,maria@test.com'); // returns false","title":"Explode"},{"location":"v2/validators/explode/#explode-validator","text":"Laminas\\Validator\\Explode executes a validator for each item exploded from an array.","title":"Explode Validator"},{"location":"v2/validators/explode/#supported-options","text":"The following options are supported for Laminas\\Validator\\Explode : valueDelimiter : Defines the delimiter used to explode values from an array. It defaults to , . If the given value is an array, this option isn't used. validator : Sets the validator that will be executed on each exploded item. This may be a validator instance, or a validator service name.","title":"Supported options"},{"location":"v2/validators/explode/#basic-usage","text":"To validate if every item in an array is in a specified haystack: $inArrayValidator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; [1, 2, 3, 4, 5, 6], ]); $explodeValidator = new Laminas\\Validator\\Explode([ 'validator' =&gt; $inArrayValidator ]); $explodeValidator-&gt;isValid([1, 4, 6]); // returns true $explodeValidator-&gt;isValid([1, 4, 6, 8]); // returns false","title":"Basic usage"},{"location":"v2/validators/explode/#exploding-strings","text":"To validate if every e-mail in a string is contained in a list of names: $inEmailListValidator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['joseph@test.com', 'mark@test.com', 'lucia@test.com'], ]); $explodeValidator = new Laminas\\Validator\\Explode([ 'validator' =&gt; $inEmailListValidator, 'valueDelimiter' =&gt; ',' ]); $explodeValidator-&gt;isValid('joseph@test.com,mark@test.com'); // returns true $explodeValidator-&gt;isValid('lucia@test.com,maria@test.com'); // returns false","title":"Exploding strings"},{"location":"v2/validators/greater-than/","text":"GreaterThan Validator Deprecated This validator is deprecated in favour of the NumberComparison validator and the DateComparison validator for validation of dates. This validator will be removed in version 3.0. Laminas\\Validator\\GreaterThan allows you to validate if a given value is greater than a minimum border value. Only supports numbers Laminas\\Validator\\GreaterThan supports only the validation of numbers. Strings or dates can not be validated with this validator. Supported options The following options are supported for Laminas\\Validator\\GreaterThan : inclusive : Defines if the validation is inclusive of the minimum value, or exclusive. It defaults to false . min : Sets the minimum allowed value. Basic usage To validate if a given value is greater than a defined minimum: $valid = new Laminas\\Validator\\GreaterThan(['min' =&gt; 10]); $value = 8; $return = $valid-&gt;isValid($value); // returns false The above example returns true for all values which are greater than 10. Inclusive validation Sometimes it is useful to validate a value by including the minimum value. $valid = new Laminas\\Validator\\GreaterThan([ 'min' =&gt; 10, 'inclusive' =&gt; true, ]); $value = 10; $result = $valid-&gt;isValid($value); // returns true The example is identical to our first example, with the exception that we included the minimum value. Now the value '10' is allowed and will return true .","title":"GreaterThan"},{"location":"v2/validators/greater-than/#greaterthan-validator","text":"Deprecated This validator is deprecated in favour of the NumberComparison validator and the DateComparison validator for validation of dates. This validator will be removed in version 3.0. Laminas\\Validator\\GreaterThan allows you to validate if a given value is greater than a minimum border value.","title":"GreaterThan Validator"},{"location":"v2/validators/greater-than/#supported-options","text":"The following options are supported for Laminas\\Validator\\GreaterThan : inclusive : Defines if the validation is inclusive of the minimum value, or exclusive. It defaults to false . min : Sets the minimum allowed value.","title":"Supported options"},{"location":"v2/validators/greater-than/#basic-usage","text":"To validate if a given value is greater than a defined minimum: $valid = new Laminas\\Validator\\GreaterThan(['min' =&gt; 10]); $value = 8; $return = $valid-&gt;isValid($value); // returns false The above example returns true for all values which are greater than 10.","title":"Basic usage"},{"location":"v2/validators/greater-than/#inclusive-validation","text":"Sometimes it is useful to validate a value by including the minimum value. $valid = new Laminas\\Validator\\GreaterThan([ 'min' =&gt; 10, 'inclusive' =&gt; true, ]); $value = 10; $result = $valid-&gt;isValid($value); // returns true The example is identical to our first example, with the exception that we included the minimum value. Now the value '10' is allowed and will return true .","title":"Inclusive validation"},{"location":"v2/validators/hex/","text":"Hex Validator Laminas\\Validator\\Hex allows you to validate if a given value contains only hexadecimal characters. These are all characters from 0 to 9 and A to F , case insensitive. There is no length limitation for the input you want to validate. $validator = new Laminas\\Validator\\Hex(); if ($validator-&gt;isValid('123ABC')) { // value contains only hex chars } else { // false } Invalid characters All other characters will return false, including whitespace and decimal points. Additionally, unicode zeros and numbers from other scripts than latin will not be treated as valid. Supported options There are no additional options for Laminas\\Validator\\Hex .","title":"Hex"},{"location":"v2/validators/hex/#hex-validator","text":"Laminas\\Validator\\Hex allows you to validate if a given value contains only hexadecimal characters. These are all characters from 0 to 9 and A to F , case insensitive. There is no length limitation for the input you want to validate. $validator = new Laminas\\Validator\\Hex(); if ($validator-&gt;isValid('123ABC')) { // value contains only hex chars } else { // false }","title":"Hex Validator"},{"location":"v2/validators/hex/#supported-options","text":"There are no additional options for Laminas\\Validator\\Hex .","title":"Supported options"},{"location":"v2/validators/host-with-public-ipv4-address/","text":"Host with Public IPv4 Address Validator Laminas\\Validator\\HostWithPublicIPv4Address allows you to validate that an IP address is not a reserved address such as 127.0.0.1, or that a hostname does not point to a known, reserved address. Supported options This validator has no options Basic usage $validator = new Laminas\\Validator\\HostWithPublicIPv4Address(); if ($validator-&gt;isValid('example.com')) { // hostname appears to be valid } else { // hostname is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } $validator = new Laminas\\Validator\\HostWithPublicIPv4Address(); if ($validator-&gt;isValid('192.168.0.1')) { // hostname appears to be valid } else { // hostname is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } Hostnames with multiple records When validating a hostname as opposed to an IP address, if that hostname resolves to multiple IPv4 addresses and any of those addresses are private or reserved, then the validator will deem the hostname invalid.","title":"HostWithPublicIPv4Address"},{"location":"v2/validators/host-with-public-ipv4-address/#host-with-public-ipv4-address-validator","text":"Laminas\\Validator\\HostWithPublicIPv4Address allows you to validate that an IP address is not a reserved address such as 127.0.0.1, or that a hostname does not point to a known, reserved address.","title":"Host with Public IPv4 Address Validator"},{"location":"v2/validators/host-with-public-ipv4-address/#supported-options","text":"This validator has no options","title":"Supported options"},{"location":"v2/validators/host-with-public-ipv4-address/#basic-usage","text":"$validator = new Laminas\\Validator\\HostWithPublicIPv4Address(); if ($validator-&gt;isValid('example.com')) { // hostname appears to be valid } else { // hostname is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } $validator = new Laminas\\Validator\\HostWithPublicIPv4Address(); if ($validator-&gt;isValid('192.168.0.1')) { // hostname appears to be valid } else { // hostname is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } }","title":"Basic usage"},{"location":"v2/validators/host-with-public-ipv4-address/#hostnames-with-multiple-records","text":"When validating a hostname as opposed to an IP address, if that hostname resolves to multiple IPv4 addresses and any of those addresses are private or reserved, then the validator will deem the hostname invalid.","title":"Hostnames with multiple records"},{"location":"v2/validators/hostname/","text":"Hostname Validator Laminas\\Validator\\Hostname allows you to validate a hostname against a set of known specifications. It is possible to check for three different types of hostnames: a DNS Hostname (i.e. domain.com ), IP address (i.e. 1.2.3.4), and Local hostnames (i.e. localhost). By default, only DNS hostnames are matched. Supported options The following options are supported for Laminas\\Validator\\Hostname : allow : Defines the sort of hostname which is allowed to be used. See below for details. idn : Defines if IDN domains are allowed or not. This option defaults to true . ip : Allows defining a custom IP validator. This option defaults to a new instance of Laminas\\Validator\\Ip . tld : Defines if TLDs are validated. This option defaults to true . Basic usage $validator = new Laminas\\Validator\\Hostname(); if ($validator-&gt;isValid($hostname)) { // hostname appears to be valid } else { // hostname is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } This will match the hostname $hostname and on failure populate getMessages() with useful error messages. Validating different types of hostnames You may find you also want to match IP addresses, Local hostnames, or a combination of all allowed types. This can be done by passing a parameter to Laminas\\Validator\\Hostname when you instantiate it. The parameter should be an integer which determines what types of hostnames are allowed. You are encouraged to use the Laminas\\Validator\\Hostname constants to do this. The Laminas\\Validator\\Hostname constants are: ALLOW_DNS , to allow only DNS hostnames ALLOW_IP to allow IP addresses ALLOW_LOCAL to allow local network names ALLOW_URI to allow RFC3986 -compliant addresses ALLOW_ALL to allow all four above types Additional Information on ALLOW_URI ALLOW_URI allows checking hostnames according to RFC3986 . These are registered names which are used by WINS, NetInfo and also local hostnames like those defined within your hosts file. To check for IP addresses only, you can use the example below: use Laminas\\Validator\\Hostname; $validator = new Hostname(Hostname::ALLOW_IP); if ($validator-&gt;isValid($hostname)) { // hostname appears to be valid } else { // hostname is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } As well as using ALLOW_ALL to accept all common hostnames types, you can combine these types to allow for combinations. For example, to accept DNS and Local hostnames: use Laminas\\Validator\\Hostname; $validator = new Hostname(Hostname::ALLOW_DNS | Hostname::ALLOW_IP); Validating International Domains Names Some Country Code Top Level Domains (ccTLDs), such as 'de' (Germany), support international characters in domain names. These are known as International Domain Names (IDN). These domains can be matched by Laminas\\Validator\\Hostname via extended characters that are used in the validation process. At the time of writing, more than 50 ccTLDs support IDN domains. The Hostname validator matches IDN domains by default. If you wish to disable IDN validation, either pass a parameter to the Laminas\\Validator\\Hostname constructor or call the setValidateIdn() method. You can disable IDN validation by passing a second parameter to the Laminas\\Validator\\Hostname constructor in the following way. $validator = new Laminas\\Validator\\Hostname([ 'allow' =&gt; Laminas\\Validator\\Hostname::ALLOW_DNS, 'useIdnCheck' =&gt; false, ]); Alternatively you can either pass true or false to setValidateIdn() to enable or disable IDN validation. If you are trying to match an IDN hostname which isn't currently supported, it is likely it will fail validation if it has any international characters in it. Where a ccTLD file doesn't exist in Laminas/Validator/Hostname specifying the additional characters, a normal hostname validation is performed. Please note that IDNs are only validated if you allow DNS hostnames to be validated. Validating Top Level Domains By default, a hostname will be verified against a list of known TLDs. If this functionality is not required, it can be disabled in much the same way as disabling IDN support. You can disable TLD validation by passing a third parameter to the Laminas\\Validator\\Hostname constructor. In the example below we are supporting IDN validation via the second parameter. use Laminas\\Validator\\Hostname; $validator = new Hostname([ 'allow' =&gt; Hostname::ALLOW_DNS, 'useIdnCheck' =&gt; true, 'useTldCheck' =&gt; false, ]); Alternatively you can either pass true or false to setValidateTld() to enable or disable TLD validation. Please note, TLDs are only validated if you allow DNS hostnames to be validated.","title":"Hostname"},{"location":"v2/validators/hostname/#hostname-validator","text":"Laminas\\Validator\\Hostname allows you to validate a hostname against a set of known specifications. It is possible to check for three different types of hostnames: a DNS Hostname (i.e. domain.com ), IP address (i.e. 1.2.3.4), and Local hostnames (i.e. localhost). By default, only DNS hostnames are matched.","title":"Hostname Validator"},{"location":"v2/validators/hostname/#supported-options","text":"The following options are supported for Laminas\\Validator\\Hostname : allow : Defines the sort of hostname which is allowed to be used. See below for details. idn : Defines if IDN domains are allowed or not. This option defaults to true . ip : Allows defining a custom IP validator. This option defaults to a new instance of Laminas\\Validator\\Ip . tld : Defines if TLDs are validated. This option defaults to true .","title":"Supported options"},{"location":"v2/validators/hostname/#basic-usage","text":"$validator = new Laminas\\Validator\\Hostname(); if ($validator-&gt;isValid($hostname)) { // hostname appears to be valid } else { // hostname is invalid; print the reasons foreach ($validator-&gt;getMessages() as $message) { echo \"$message\\n\"; } } This will match the hostname $hostname and on failure populate getMessages() with useful error messages.","title":"Basic usage"},{"location":"v2/validators/hostname/#validating-different-types-of-hostnames","text":"You may find you also want to match IP addresses, Local hostnames, or a combination of all allowed types. This can be done by passing a parameter to Laminas\\Validator\\Hostname when you instantiate it. The parameter should be an integer which determines what types of hostnames are allowed. You are encouraged to use the Laminas\\Validator\\Hostname constants to do this. The Laminas\\Validator\\Hostname constants are: ALLOW_DNS , to allow only DNS hostnames ALLOW_IP to allow IP addresses ALLOW_LOCAL to allow local network names ALLOW_URI to allow RFC3986 -compliant addresses ALLOW_ALL to allow all four above types","title":"Validating different types of hostnames"},{"location":"v2/validators/hostname/#validating-international-domains-names","text":"Some Country Code Top Level Domains (ccTLDs), such as 'de' (Germany), support international characters in domain names. These are known as International Domain Names (IDN). These domains can be matched by Laminas\\Validator\\Hostname via extended characters that are used in the validation process. At the time of writing, more than 50 ccTLDs support IDN domains. The Hostname validator matches IDN domains by default. If you wish to disable IDN validation, either pass a parameter to the Laminas\\Validator\\Hostname constructor or call the setValidateIdn() method. You can disable IDN validation by passing a second parameter to the Laminas\\Validator\\Hostname constructor in the following way. $validator = new Laminas\\Validator\\Hostname([ 'allow' =&gt; Laminas\\Validator\\Hostname::ALLOW_DNS, 'useIdnCheck' =&gt; false, ]); Alternatively you can either pass true or false to setValidateIdn() to enable or disable IDN validation. If you are trying to match an IDN hostname which isn't currently supported, it is likely it will fail validation if it has any international characters in it. Where a ccTLD file doesn't exist in Laminas/Validator/Hostname specifying the additional characters, a normal hostname validation is performed. Please note that IDNs are only validated if you allow DNS hostnames to be validated.","title":"Validating International Domains Names"},{"location":"v2/validators/hostname/#validating-top-level-domains","text":"By default, a hostname will be verified against a list of known TLDs. If this functionality is not required, it can be disabled in much the same way as disabling IDN support. You can disable TLD validation by passing a third parameter to the Laminas\\Validator\\Hostname constructor. In the example below we are supporting IDN validation via the second parameter. use Laminas\\Validator\\Hostname; $validator = new Hostname([ 'allow' =&gt; Hostname::ALLOW_DNS, 'useIdnCheck' =&gt; true, 'useTldCheck' =&gt; false, ]); Alternatively you can either pass true or false to setValidateTld() to enable or disable TLD validation. Please note, TLDs are only validated if you allow DNS hostnames to be validated.","title":"Validating Top Level Domains"},{"location":"v2/validators/iban/","text":"Iban Validator Laminas\\Validator\\Iban validates if a given value could be a IBAN number. IBAN is the abbreviation for \"International Bank Account Number\". Supported options The following options are supported for Laminas\\Validator\\Iban : country_code : Sets the country code which is used to get the IBAN format for validation. IBAN validation IBAN numbers are always related to a country. This means that different countries use different formats for their IBAN numbers. This is the reason why IBAN numbers always need a country code. By knowing this we already know how to use Laminas\\Validator\\Iban . Ungreedy IBAN validation Sometime it is useful just to validate if the given value is a IBAN number or not. This means that you don't want to validate it against a defined country. This can be done by using false as locale. $validator = new Laminas\\Validator\\Iban(['country_code' =&gt; false]); // Note: you can also provide FALSE as the sole parameter if ($validator-&gt;isValid('AT611904300234573201')) { // IBAN appears to be valid } else { // IBAN is not valid } In this situation, any IBAN number from any country will considered valid. Note that this should not be done when you accept only accounts from a single country! Region aware IBAN validation To validate against a defined country, you just provide a country code. You can do this during instaniation via the option country_code , or afterwards by using setCountryCode() . $validator = new Laminas\\Validator\\Iban(['country_code' =&gt; 'AT']); if ($validator-&gt;isValid('AT611904300234573201')) { // IBAN appears to be valid } else { // IBAN is not valid }","title":"Iban"},{"location":"v2/validators/iban/#iban-validator","text":"Laminas\\Validator\\Iban validates if a given value could be a IBAN number. IBAN is the abbreviation for \"International Bank Account Number\".","title":"Iban Validator"},{"location":"v2/validators/iban/#supported-options","text":"The following options are supported for Laminas\\Validator\\Iban : country_code : Sets the country code which is used to get the IBAN format for validation.","title":"Supported options"},{"location":"v2/validators/iban/#iban-validation","text":"IBAN numbers are always related to a country. This means that different countries use different formats for their IBAN numbers. This is the reason why IBAN numbers always need a country code. By knowing this we already know how to use Laminas\\Validator\\Iban .","title":"IBAN validation"},{"location":"v2/validators/identical/","text":"Identical Validator Laminas\\Validator\\Identical allows you to validate if a given value is identical with a set token. Supported options The following options are supported for Laminas\\Validator\\Identical : strict : Defines if the validation should be strict (i.e., if types should also be considered). The default value is true . token : Sets the token against which the input will be validated. literal : If set to true , the validation will skip the lookup for elements in the form context, and validate the token just the way it was provided. The default value is false . Basic usage To validate if two values are identical, you need to set the original value as the token, as demonstrated in the following example: token. $valid = new Laminas\\Validator\\Identical('origin'); if ($valid-&gt;isValid($value)) { return true; } The validation will only then return true when both values are 100% identical. In our example, when $value is 'origin' . You can set the token after instantiation by using the method setToken() . Identical objects Laminas\\Validator\\Identical can validate not only strings, but any other variable type, such as booleans, integers, floats, arrays, or even objects. As already noted, the token and value must be identical. $valid = new Laminas\\Validator\\Identical(123); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } Type comparison You should be aware of the variable type used for validation. This means that the string '3' is not identical to integer 3 . When you want non-strict validation, you must set the strict option to false . Form elements Laminas\\Validator\\Identical supports the comparison of form elements. This can be done by using the element's name as the token : $form-&gt;add([ 'name' =&gt; 'elementOne', 'type' =&gt; 'Password', ]); $form-&gt;add([ 'name' =&gt; 'elementTwo', 'type' =&gt; 'Password', 'validators' =&gt; [ [ 'name' =&gt; 'Identical', 'options' =&gt; [ 'token' =&gt; 'elementOne', ], ], ], ]); By using the element's name from the first element as the token for the second element, the validator validates if the second element is equal with the first element. In the case your user does not enter two identical values, you will get a validation error. Validating a Value From a Fieldset Sometimes you will need to validate an input that lives inside a fieldset, and this can be accomplished as follows: use Laminas\\Form\\Element; use Laminas\\Form\\Fieldset; use Laminas\\Form\\Form; use Laminas\\InputFilter\\Input; use Laminas\\InputFilter\\InputFilter; $userFieldset = new Fieldset('user'); // (1) $userFieldset-&gt;add([ 'name' =&gt; 'email', // (2) 'type' =&gt; 'Email', ]); // Let's add one fieldset inside the 'user' fieldset, // so we can see how to manage the token in a different deepness $deeperFieldset = new Fieldset('deeperFieldset'); // (3) $deeperFieldset-&gt;add([ 'name' =&gt; 'deeperFieldsetInput', // (4) 'type' =&gt; 'Text', 'options' =&gt; [ 'label' =&gt; 'What validator are we testing?', ], ]); $userFieldset-&gt;add($deeperFieldset); $signUpForm = new Form('signUp'); $signUpForm-&gt;add($userFieldset); // Add an input that will validate the 'email' input from 'user' fieldset $signUpForm-&gt;add([ 'name' =&gt; 'confirmEmail', // (5) 'type' =&gt; 'Email', ]); // Add an input that will validate the 'deeperFieldsetInput' from // 'deeperFieldset' that lives inside the 'user' fieldset $signUpForm-&gt;add([ 'name' =&gt; 'confirmTestingValidator', // (6) 'type' =&gt; 'Text', ]); // This will ensure the user enter the same email in 'email' (2) and // 'confirmEmail' (5) $inputFilter = new InputFilter(); $inputFilter-&gt;add([ 'name' =&gt; 'confirmEmail', // references (5) 'validators' =&gt; [ [ 'name' =&gt; 'Identical', 'options' =&gt; [ // 'user' key references 'user' fieldset (1), and 'email' // references 'email' element inside 'user' fieldset (2) 'token' =&gt; ['user' =&gt; 'email'], ], ], ], ]); // This will ensure the user enter the same string in 'deeperFieldsetInput' (4) // and 'confirmTestingValidator' (6) $inputFilter-&gt;add([ 'name' =&gt; 'confirmTestingValidator', // references (6) 'validators' =&gt; [ [ 'name' =&gt; 'Identical', 'options' =&gt; [ 'token' =&gt; [ 'user' =&gt; [ // references 'user' fieldset (1) // 'deeperFieldset' key references 'deeperFieldset' // fieldset (3); 'deeperFieldsetInput' references // 'deeperFieldsetInput' element (4) 'deeperFieldset' =&gt; 'deeperFieldsetInput', ], ], ], ], ], ]); $signUpForm-&gt;setInputFilter($inputFilter); Use one token per leaf Aways make sure that your token array have just one key per level all the way till the leaf, otherwise you can end up with unexpected results. Strict validation As mentioned before, Laminas\\Validator\\Identical validates tokens using strict typing. You can change this behaviour by using the strict option. The default value for this property is true . $valid = new Laminas\\Validator\\Identical(['token' =&gt; 123, 'strict' =&gt; false]); $input = '123'; if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } The difference to the previous example is that the validation returns in this case true , even if you compare a integer with string value as long as the content is identical but not the type. For convenience you can also use setStrict() and getStrict() . Configuration As all other validators, Laminas\\Validator\\Identical also supports the usage of configuration settings during instantiation. This means that you can configure this validator with a Traversable object. There is a case which you should be aware of. If you are using an array as token, and it contains a token key, you should wrap it within another token key. See the examples below to understand this situation. // This will not validate ['token' =&gt; 123], it will actually validate the // integer 123 $valid = new Laminas\\Validator\\Identical(['token' =&gt; 123]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } The reason for this special case is that you can configure the token which has to be used by giving the token key. So, when you are using an array as the token, and it contains one element with a token key, then you have to wrap it as shown in the example below: // Unlike the previous example, this will validate ['token' =&gt; 123] $valid = new Laminas\\Validator\\Identical(['token' =&gt; ['token' =&gt; 123]]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } If the array you are willing to validate does not have a token key, you do not need to wrap it.","title":"Identical"},{"location":"v2/validators/identical/#identical-validator","text":"Laminas\\Validator\\Identical allows you to validate if a given value is identical with a set token.","title":"Identical Validator"},{"location":"v2/validators/identical/#supported-options","text":"The following options are supported for Laminas\\Validator\\Identical : strict : Defines if the validation should be strict (i.e., if types should also be considered). The default value is true . token : Sets the token against which the input will be validated. literal : If set to true , the validation will skip the lookup for elements in the form context, and validate the token just the way it was provided. The default value is false .","title":"Supported options"},{"location":"v2/validators/identical/#basic-usage","text":"To validate if two values are identical, you need to set the original value as the token, as demonstrated in the following example: token. $valid = new Laminas\\Validator\\Identical('origin'); if ($valid-&gt;isValid($value)) { return true; } The validation will only then return true when both values are 100% identical. In our example, when $value is 'origin' . You can set the token after instantiation by using the method setToken() .","title":"Basic usage"},{"location":"v2/validators/identical/#identical-objects","text":"Laminas\\Validator\\Identical can validate not only strings, but any other variable type, such as booleans, integers, floats, arrays, or even objects. As already noted, the token and value must be identical. $valid = new Laminas\\Validator\\Identical(123); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid }","title":"Identical objects"},{"location":"v2/validators/identical/#form-elements","text":"Laminas\\Validator\\Identical supports the comparison of form elements. This can be done by using the element's name as the token : $form-&gt;add([ 'name' =&gt; 'elementOne', 'type' =&gt; 'Password', ]); $form-&gt;add([ 'name' =&gt; 'elementTwo', 'type' =&gt; 'Password', 'validators' =&gt; [ [ 'name' =&gt; 'Identical', 'options' =&gt; [ 'token' =&gt; 'elementOne', ], ], ], ]); By using the element's name from the first element as the token for the second element, the validator validates if the second element is equal with the first element. In the case your user does not enter two identical values, you will get a validation error.","title":"Form elements"},{"location":"v2/validators/identical/#strict-validation","text":"As mentioned before, Laminas\\Validator\\Identical validates tokens using strict typing. You can change this behaviour by using the strict option. The default value for this property is true . $valid = new Laminas\\Validator\\Identical(['token' =&gt; 123, 'strict' =&gt; false]); $input = '123'; if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } The difference to the previous example is that the validation returns in this case true , even if you compare a integer with string value as long as the content is identical but not the type. For convenience you can also use setStrict() and getStrict() .","title":"Strict validation"},{"location":"v2/validators/identical/#configuration","text":"As all other validators, Laminas\\Validator\\Identical also supports the usage of configuration settings during instantiation. This means that you can configure this validator with a Traversable object. There is a case which you should be aware of. If you are using an array as token, and it contains a token key, you should wrap it within another token key. See the examples below to understand this situation. // This will not validate ['token' =&gt; 123], it will actually validate the // integer 123 $valid = new Laminas\\Validator\\Identical(['token' =&gt; 123]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } The reason for this special case is that you can configure the token which has to be used by giving the token key. So, when you are using an array as the token, and it contains one element with a token key, then you have to wrap it as shown in the example below: // Unlike the previous example, this will validate ['token' =&gt; 123] $valid = new Laminas\\Validator\\Identical(['token' =&gt; ['token' =&gt; 123]]); if ($valid-&gt;isValid($input)) { // input appears to be valid } else { // input is invalid } If the array you are willing to validate does not have a token key, you do not need to wrap it.","title":"Configuration"},{"location":"v2/validators/in-array/","text":"InArray Validator Laminas\\Validator\\InArray allows you to validate if a given value is contained within an array. It is also able to validate multidimensional arrays. Supported options The following options are supported for Laminas\\Validator\\InArray : haystack : Sets the haystack for the validation. recursive : Defines if the validation should be done recursively. This option defaults to false . strict : Three modes of comparison are offered owing to an often overlooked, and potentially dangerous security issue when validating string input from user input. InArray::COMPARE_STRICT : This is a normal in_array() strict comparison that checks value and type. InArray::COMPARE_NOT_STRICT : This is a normal in_array() non-strict comparison that checks value only, but not type. InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILTY : This operates in essentially the same way as InArray::COMPARE_NOT_STRICT , but ensures that strings are not cast to integer during comparison, preventing 0 == 'foo43' types of false positives. Use non-strict carefully Non-strict mode ( InArray::COMPARE_NOT_STRICT ) may give false positives when strings are compared against ints or floats owing to in_array() 's behaviour of converting strings to int in such cases. Therefore, 'foo' would become 0 , '43foo' would become 43 , while foo43' would also become 0 . Array validation Basic usage is to provide an array during instantiation: $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2',...'valueN'], ]); if ($validator-&gt;isValid('value')) { // value found } else { // no value found } This will behave exactly like PHP's in_array() method when passed only a needle and haystack. Non-strict by default By default, this validation is not strict, nor can it validate multidimensional arrays. Alternately, you can define the array to validate against after object construction by using the setHaystack() method. getHaystack() returns the actual set haystack array. $validator = new Laminas\\Validator\\InArray(); $validator-&gt;setHaystack(['value1', 'value2',...'valueN']); if ($validator-&gt;isValid('value')) { // value found } else { // no value found } Array validation modes As previously mentioned, there are possible security issues when using the default non-strict comparison mode, so rather than restricting the developer, we've chosen to offer both strict and non-strict comparisons, and add a safer middle-ground. It's possible to set the strict mode at initialisation and afterwards with the setStrict method. InArray::COMPARE_STRICT equates to true and InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY equates to false . // defaults to InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2', /* ... */ 'valueN'], ]); // set strict mode $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2', /* ... */ 'valueN'], 'strict' =&gt; InArray::COMPARE_STRICT, // equates to ``true`` ]); // set non-strict mode $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2', /* ... */ 'valueN'], 'strict' =&gt; InArray:COMPARE_NOT_STRICT, // equates to ``false`` ]); // or $validator-&gt;setStrict(InArray::COMPARE_STRICT); $validator-&gt;setStrict(InArray::COMPARE_NOT_STRICT); $validator-&gt;setStrict(InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY); Non-strict safe-mode by default Note that the strict setting is per default false . Recursive array validation In addition to PHP's in_array() method, this validator can also be used to validate multidimensional arrays. To validate multidimensional arrays you have to set the recursive option. $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; [ 'firstDimension' =&gt; ['value1', 'value2', / ... */ 'valueN'], 'secondDimension' =&gt; ['foo1', 'foo2', /* ... */ 'fooN'], ], 'recursive' =&gt; true, ]); if ($validator-&gt;isValid('value')) { // value found } else { // no value found } Your array will then be validated recursively to see if the given value is contained. Additionally you could use setRecursive() to set this option afterwards and getRecursive() to retrieve it. $validator = new Laminas\\Validator\\InArray([ 'firstDimension' =&gt; ['value1', 'value2', /* ... */ 'valueN'], 'secondDimension' =&gt; ['foo1', 'foo2', /* ... */ 'fooN'], ]); $validator-&gt;setRecursive(true); if ($validator-&gt;isValid('value')) { // value found } else { // no value found } Default setting for recursion By default, the recursive validation is turned off. Option keys within the haystack When you are using the keys haystack , strict , or recursive within your haystack, then you must wrap the haystack key.","title":"InArray"},{"location":"v2/validators/in-array/#inarray-validator","text":"Laminas\\Validator\\InArray allows you to validate if a given value is contained within an array. It is also able to validate multidimensional arrays.","title":"InArray Validator"},{"location":"v2/validators/in-array/#supported-options","text":"The following options are supported for Laminas\\Validator\\InArray : haystack : Sets the haystack for the validation. recursive : Defines if the validation should be done recursively. This option defaults to false . strict : Three modes of comparison are offered owing to an often overlooked, and potentially dangerous security issue when validating string input from user input. InArray::COMPARE_STRICT : This is a normal in_array() strict comparison that checks value and type. InArray::COMPARE_NOT_STRICT : This is a normal in_array() non-strict comparison that checks value only, but not type. InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILTY : This operates in essentially the same way as InArray::COMPARE_NOT_STRICT , but ensures that strings are not cast to integer during comparison, preventing 0 == 'foo43' types of false positives.","title":"Supported options"},{"location":"v2/validators/in-array/#array-validation","text":"Basic usage is to provide an array during instantiation: $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2',...'valueN'], ]); if ($validator-&gt;isValid('value')) { // value found } else { // no value found } This will behave exactly like PHP's in_array() method when passed only a needle and haystack.","title":"Array validation"},{"location":"v2/validators/in-array/#array-validation-modes","text":"As previously mentioned, there are possible security issues when using the default non-strict comparison mode, so rather than restricting the developer, we've chosen to offer both strict and non-strict comparisons, and add a safer middle-ground. It's possible to set the strict mode at initialisation and afterwards with the setStrict method. InArray::COMPARE_STRICT equates to true and InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY equates to false . // defaults to InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2', /* ... */ 'valueN'], ]); // set strict mode $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2', /* ... */ 'valueN'], 'strict' =&gt; InArray::COMPARE_STRICT, // equates to ``true`` ]); // set non-strict mode $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; ['value1', 'value2', /* ... */ 'valueN'], 'strict' =&gt; InArray:COMPARE_NOT_STRICT, // equates to ``false`` ]); // or $validator-&gt;setStrict(InArray::COMPARE_STRICT); $validator-&gt;setStrict(InArray::COMPARE_NOT_STRICT); $validator-&gt;setStrict(InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY);","title":"Array validation modes"},{"location":"v2/validators/in-array/#recursive-array-validation","text":"In addition to PHP's in_array() method, this validator can also be used to validate multidimensional arrays. To validate multidimensional arrays you have to set the recursive option. $validator = new Laminas\\Validator\\InArray([ 'haystack' =&gt; [ 'firstDimension' =&gt; ['value1', 'value2', / ... */ 'valueN'], 'secondDimension' =&gt; ['foo1', 'foo2', /* ... */ 'fooN'], ], 'recursive' =&gt; true, ]); if ($validator-&gt;isValid('value')) { // value found } else { // no value found } Your array will then be validated recursively to see if the given value is contained. Additionally you could use setRecursive() to set this option afterwards and getRecursive() to retrieve it. $validator = new Laminas\\Validator\\InArray([ 'firstDimension' =&gt; ['value1', 'value2', /* ... */ 'valueN'], 'secondDimension' =&gt; ['foo1', 'foo2', /* ... */ 'fooN'], ]); $validator-&gt;setRecursive(true); if ($validator-&gt;isValid('value')) { // value found } else { // no value found }","title":"Recursive array validation"},{"location":"v2/validators/ip/","text":"Ip Validator Laminas\\Validator\\Ip allows you to validate if a given value is an IP address. It supports the IPv4, IPv6, and IPvFuture definitions. Supported options The following options are supported for Laminas\\Validator\\Ip : allowipv4 : Defines if the validator allows IPv4 addresses. This option defaults to true . allowipv6 : Defines if the validator allows IPv6 addresses. This option defaults to true . allowipvfuture : Defines if the validator allows IPvFuture addresses. This option defaults to false . allowliteral : Defines if the validator allows IPv6 or IPvFuture with URI literal style (the IP surrounded by brackets). This option defaults to true . Basic usage $validator = new Laminas\\Validator\\Ip(); if ($validator-&gt;isValid($ip)) { // ip appears to be valid } else { // ip is invalid; print the reasons } Invalid IP addresses Keep in mind that Laminas\\Validator\\Ip only validates IP addresses. Addresses like ' mydomain.com ' or ' 192.168.50.1/index.html ' are not valid IP addresses. They are either hostnames or valid URLs but not IP addresses. IPv6/IPvFuture validation Laminas\\Validator\\Ip validates IPv6/IPvFuture addresses using a regex. The reason is that the filters and methods from PHP itself don't follow the RFC. Many other available classes also don't follow it. Validate IPv4 or IPV6 alone Sometimes it's useful to validate only one of the supported formats; e.g., when your network only supports IPv4. In this case it would be useless to allow IPv6 within this validator. To limit Laminas\\Validator\\Ip to one protocol, you can set the options allowipv4 or allowipv6 to false . You can do this either by giving the option to the constructor or by using setOptions() afterwards. $validator = new Laminas\\Validator\\Ip(['allowipv6' =&gt; false]); if ($validator-&gt;isValid($ip)) { // ip appears to be valid ipv4 address } else { // ip is not an ipv4 address } Default behaviour The default behaviour which Laminas\\Validator\\Ip follows is to allow both standards.","title":"Ip"},{"location":"v2/validators/ip/#ip-validator","text":"Laminas\\Validator\\Ip allows you to validate if a given value is an IP address. It supports the IPv4, IPv6, and IPvFuture definitions.","title":"Ip Validator"},{"location":"v2/validators/ip/#supported-options","text":"The following options are supported for Laminas\\Validator\\Ip : allowipv4 : Defines if the validator allows IPv4 addresses. This option defaults to true . allowipv6 : Defines if the validator allows IPv6 addresses. This option defaults to true . allowipvfuture : Defines if the validator allows IPvFuture addresses. This option defaults to false . allowliteral : Defines if the validator allows IPv6 or IPvFuture with URI literal style (the IP surrounded by brackets). This option defaults to true .","title":"Supported options"},{"location":"v2/validators/ip/#basic-usage","text":"$validator = new Laminas\\Validator\\Ip(); if ($validator-&gt;isValid($ip)) { // ip appears to be valid } else { // ip is invalid; print the reasons }","title":"Basic usage"},{"location":"v2/validators/ip/#validate-ipv4-or-ipv6-alone","text":"Sometimes it's useful to validate only one of the supported formats; e.g., when your network only supports IPv4. In this case it would be useless to allow IPv6 within this validator. To limit Laminas\\Validator\\Ip to one protocol, you can set the options allowipv4 or allowipv6 to false . You can do this either by giving the option to the constructor or by using setOptions() afterwards. $validator = new Laminas\\Validator\\Ip(['allowipv6' =&gt; false]); if ($validator-&gt;isValid($ip)) { // ip appears to be valid ipv4 address } else { // ip is not an ipv4 address }","title":"Validate IPv4 or IPV6 alone"},{"location":"v2/validators/is-array/","text":"IsArray Validator Since 2.52.0 Laminas\\Validator\\IsArray checks that a given value is an array. There are no options. Example Usage $validator = new Laminas\\Validator\\IsArray(); $validator-&gt;isValid('Not an Array'); // false $validator-&gt;isValid(['Any Array']); // true","title":"IsArray"},{"location":"v2/validators/is-array/#isarray-validator","text":"Since 2.52.0 Laminas\\Validator\\IsArray checks that a given value is an array. There are no options.","title":"IsArray Validator"},{"location":"v2/validators/is-array/#example-usage","text":"$validator = new Laminas\\Validator\\IsArray(); $validator-&gt;isValid('Not an Array'); // false $validator-&gt;isValid(['Any Array']); // true","title":"Example Usage"},{"location":"v2/validators/is-countable/","text":"IsCountable Validator Since 2.10.0 Laminas\\Validator\\IsCountable allows you to validate that a value can be counted (i.e., it's an array or implements Countable ), and, optionally: the exact count of the value the minimum count of the value the maximum count of the value Specifying either of the latter two is inconsistent with the first, and, as such, the validator does not allow setting both a count and a minimum or maximum value. You may, however specify both minimum and maximum values, in which case the validator operates similar to the Between validator . Supported options The following options are supported for Laminas\\Validator\\IsCountable : count : Defines if the validation should look for a specific, exact count for the value provided. max : Sets the maximum value for the validation; if the count of the value is greater than the maximum, validation fails.. min : Sets the minimum value for the validation; if the count of the value is lower than the minimum, validation fails. Default behaviour Given no options, the validator simply tests to see that the value may be counted (i.e., it's an array or Countable instance): $validator = new Laminas\\Validator\\IsCountable(); $validator-&gt;isValid(10); // false; not an array or Countable $validator-&gt;isValid([10]); // true; value is an array $validator-&gt;isValid(new ArrayObject([10])); // true; value is Countable $validator-&gt;isValid(new stdClass); // false; value is not Countable Specifying an exact count You can also specify an exact count; if the value is countable, and its count matches, the the value is valid. $validator = new Laminas\\Validator\\IsCountable(['count' =&gt; 3]); $validator-&gt;isValid([1, 2, 3]); // true; countable, and count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3 $validator-&gt;isValid([1]); // false; countable, but count is 1 $validator-&gt;isValid(new ArrayObject([1])); // false; countable, but count is 1 Specifying a minimum count You may specify a minimum count. When you do, the value must be countable, and greater than or equal to the minimum count you specify in order to be valid. $validator = new Laminas\\Validator\\IsCountable(['min' =&gt; 2]); $validator-&gt;isValid([1, 2, 3]); // true; countable, and count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3 $validator-&gt;isValid([1, 2]); // true; countable, and count is 2 $validator-&gt;isValid(new ArrayObject([1, 2])); // true; countable, and count is 2 $validator-&gt;isValid([1]); // false; countable, but count is 1 $validator-&gt;isValid(new ArrayObject([1])); // false; countable, but count is 1 Specifying a maximum count You may specify a maximum count. When you do, the value must be countable, and less than or equal to the maximum count you specify in order to be valid. $validator = new Laminas\\Validator\\IsCountable(['max' =&gt; 2]); $validator-&gt;isValid([1, 2, 3]); // false; countable, but count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // false; countable, but count is 3 $validator-&gt;isValid([1, 2]); // true; countable, and count is 2 $validator-&gt;isValid(new ArrayObject([1, 2])); // true; countable, and count is 2 $validator-&gt;isValid([1]); // true; countable, and count is 1 $validator-&gt;isValid(new ArrayObject([1])); // true; countable, and count is 1 Specifying both minimum and maximum If you specify both a minimum and maximum, the count must be between the two, inclusively (i.e., it may be the minimum or maximum, and any value between). $validator = new Laminas\\Validator\\IsCountable([ 'min' =&gt; 3, 'max' =&gt; 5, ]); $validator-&gt;isValid([1, 2, 3]); // true; countable, and count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3 $validator-&gt;isValid(range(1, 5)); // true; countable, and count is 5 $validator-&gt;isValid(new ArrayObject(range(1, 5))); // true; countable, and count is 5 $validator-&gt;isValid([1, 2]); // false; countable, and count is 2 $validator-&gt;isValid(new ArrayObject([1, 2])); // false; countable, and count is 2 $validator-&gt;isValid(range(1, 6)); // false; countable, and count is 6 $validator-&gt;isValid(new ArrayObject(range(1, 6))); // false; countable, and count is 6","title":"IsCountable"},{"location":"v2/validators/is-countable/#iscountable-validator","text":"Since 2.10.0 Laminas\\Validator\\IsCountable allows you to validate that a value can be counted (i.e., it's an array or implements Countable ), and, optionally: the exact count of the value the minimum count of the value the maximum count of the value Specifying either of the latter two is inconsistent with the first, and, as such, the validator does not allow setting both a count and a minimum or maximum value. You may, however specify both minimum and maximum values, in which case the validator operates similar to the Between validator .","title":"IsCountable Validator"},{"location":"v2/validators/is-countable/#supported-options","text":"The following options are supported for Laminas\\Validator\\IsCountable : count : Defines if the validation should look for a specific, exact count for the value provided. max : Sets the maximum value for the validation; if the count of the value is greater than the maximum, validation fails.. min : Sets the minimum value for the validation; if the count of the value is lower than the minimum, validation fails.","title":"Supported options"},{"location":"v2/validators/is-countable/#default-behaviour","text":"Given no options, the validator simply tests to see that the value may be counted (i.e., it's an array or Countable instance): $validator = new Laminas\\Validator\\IsCountable(); $validator-&gt;isValid(10); // false; not an array or Countable $validator-&gt;isValid([10]); // true; value is an array $validator-&gt;isValid(new ArrayObject([10])); // true; value is Countable $validator-&gt;isValid(new stdClass); // false; value is not Countable","title":"Default behaviour"},{"location":"v2/validators/is-countable/#specifying-an-exact-count","text":"You can also specify an exact count; if the value is countable, and its count matches, the the value is valid. $validator = new Laminas\\Validator\\IsCountable(['count' =&gt; 3]); $validator-&gt;isValid([1, 2, 3]); // true; countable, and count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3 $validator-&gt;isValid([1]); // false; countable, but count is 1 $validator-&gt;isValid(new ArrayObject([1])); // false; countable, but count is 1","title":"Specifying an exact count"},{"location":"v2/validators/is-countable/#specifying-a-minimum-count","text":"You may specify a minimum count. When you do, the value must be countable, and greater than or equal to the minimum count you specify in order to be valid. $validator = new Laminas\\Validator\\IsCountable(['min' =&gt; 2]); $validator-&gt;isValid([1, 2, 3]); // true; countable, and count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3 $validator-&gt;isValid([1, 2]); // true; countable, and count is 2 $validator-&gt;isValid(new ArrayObject([1, 2])); // true; countable, and count is 2 $validator-&gt;isValid([1]); // false; countable, but count is 1 $validator-&gt;isValid(new ArrayObject([1])); // false; countable, but count is 1","title":"Specifying a minimum count"},{"location":"v2/validators/is-countable/#specifying-a-maximum-count","text":"You may specify a maximum count. When you do, the value must be countable, and less than or equal to the maximum count you specify in order to be valid. $validator = new Laminas\\Validator\\IsCountable(['max' =&gt; 2]); $validator-&gt;isValid([1, 2, 3]); // false; countable, but count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // false; countable, but count is 3 $validator-&gt;isValid([1, 2]); // true; countable, and count is 2 $validator-&gt;isValid(new ArrayObject([1, 2])); // true; countable, and count is 2 $validator-&gt;isValid([1]); // true; countable, and count is 1 $validator-&gt;isValid(new ArrayObject([1])); // true; countable, and count is 1","title":"Specifying a maximum count"},{"location":"v2/validators/is-countable/#specifying-both-minimum-and-maximum","text":"If you specify both a minimum and maximum, the count must be between the two, inclusively (i.e., it may be the minimum or maximum, and any value between). $validator = new Laminas\\Validator\\IsCountable([ 'min' =&gt; 3, 'max' =&gt; 5, ]); $validator-&gt;isValid([1, 2, 3]); // true; countable, and count is 3 $validator-&gt;isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3 $validator-&gt;isValid(range(1, 5)); // true; countable, and count is 5 $validator-&gt;isValid(new ArrayObject(range(1, 5))); // true; countable, and count is 5 $validator-&gt;isValid([1, 2]); // false; countable, and count is 2 $validator-&gt;isValid(new ArrayObject([1, 2])); // false; countable, and count is 2 $validator-&gt;isValid(range(1, 6)); // false; countable, and count is 6 $validator-&gt;isValid(new ArrayObject(range(1, 6))); // false; countable, and count is 6","title":"Specifying both minimum and maximum"},{"location":"v2/validators/is-json-string/","text":"IsJsonString Laminas\\Validator\\IsJsonString allows you to validate whether a given value is a string that will be successfully decoded by json_decode . Basic Usage $validator = new Laminas\\Validator\\IsJsonString(); $input = '{\"some\":\"json\"}'; if ($validator-&gt;isValid($input)) { // $input can be successfully decoded } else { // $input is not a valid JSON string } Restricting Acceptable JSON Types json_decode accepts numeric strings representing integers and floating point numbers, booleans, arrays and objects. You can restrict what is considered valid input using the allow option of the validator. use Laminas\\Validator\\IsJsonString; $validator = new IsJsonString([ 'allow' =&gt; IsJsonString::ALLOW_ALL ^ IsJsonString::ALLOW_BOOL, ]); $validator-&gt;isValid('true'); // false The allow option is a bit mask of the ALLOW_* constants in IsJsonString : IsJsonString::ALLOW_INT - Accept integer such as 1 IsJsonString::ALLOW_FLOAT - Accept floating-point value such as 1.234 IsJsonString::ALLOW_BOOL - Accept true and false IsJsonString::ALLOW_ARRAY - Accept JSON arrays such as [\"One\", \"Two\"] IsJsonString::ALLOW_OBJECT - Accept JSON objects such as {\"Some\":\"Object\"} IsJsonString::ALLOW_ALL - A convenience constant allowing all of the above (Also the default) . The allow option also has a companion setter method setAllow . For example, to only accept arrays and objects: use Laminas\\Validator\\IsJsonString; $validator = new IsJsonString(); $validator-&gt;setAllow(IsJsonString::ALLOW_ARRAY | IsJsonString::ALLOW_OBJECT); $validator-&gt;isValid('1.234'); // false Restricting Max Object or Array Nesting Level If you wish to restrict the nesting level of arrays and objects that are considered valid, the validator accepts a maxDepth option. The default value of this option is 512 - the same default value as json_decode . $validator = new Laminas\\Validator\\IsJsonString(['maxDepth' =&gt; 2]); $validator-&gt;isValid('{\"nested\": {\"object: \"here\"}}'); // false Again, the max nesting level allowed has a companion setter method: $validator = new Laminas\\Validator\\IsJsonString(); $validator-&gt;setMaxDepth(10);","title":"IsJsonString"},{"location":"v2/validators/is-json-string/#isjsonstring","text":"Laminas\\Validator\\IsJsonString allows you to validate whether a given value is a string that will be successfully decoded by json_decode .","title":"IsJsonString"},{"location":"v2/validators/is-json-string/#basic-usage","text":"$validator = new Laminas\\Validator\\IsJsonString(); $input = '{\"some\":\"json\"}'; if ($validator-&gt;isValid($input)) { // $input can be successfully decoded } else { // $input is not a valid JSON string }","title":"Basic Usage"},{"location":"v2/validators/is-json-string/#restricting-acceptable-json-types","text":"json_decode accepts numeric strings representing integers and floating point numbers, booleans, arrays and objects. You can restrict what is considered valid input using the allow option of the validator. use Laminas\\Validator\\IsJsonString; $validator = new IsJsonString([ 'allow' =&gt; IsJsonString::ALLOW_ALL ^ IsJsonString::ALLOW_BOOL, ]); $validator-&gt;isValid('true'); // false The allow option is a bit mask of the ALLOW_* constants in IsJsonString : IsJsonString::ALLOW_INT - Accept integer such as 1 IsJsonString::ALLOW_FLOAT - Accept floating-point value such as 1.234 IsJsonString::ALLOW_BOOL - Accept true and false IsJsonString::ALLOW_ARRAY - Accept JSON arrays such as [\"One\", \"Two\"] IsJsonString::ALLOW_OBJECT - Accept JSON objects such as {\"Some\":\"Object\"} IsJsonString::ALLOW_ALL - A convenience constant allowing all of the above (Also the default) . The allow option also has a companion setter method setAllow . For example, to only accept arrays and objects: use Laminas\\Validator\\IsJsonString; $validator = new IsJsonString(); $validator-&gt;setAllow(IsJsonString::ALLOW_ARRAY | IsJsonString::ALLOW_OBJECT); $validator-&gt;isValid('1.234'); // false","title":"Restricting Acceptable JSON Types"},{"location":"v2/validators/is-json-string/#restricting-max-object-or-array-nesting-level","text":"If you wish to restrict the nesting level of arrays and objects that are considered valid, the validator accepts a maxDepth option. The default value of this option is 512 - the same default value as json_decode . $validator = new Laminas\\Validator\\IsJsonString(['maxDepth' =&gt; 2]); $validator-&gt;isValid('{\"nested\": {\"object: \"here\"}}'); // false Again, the max nesting level allowed has a companion setter method: $validator = new Laminas\\Validator\\IsJsonString(); $validator-&gt;setMaxDepth(10);","title":"Restricting Max Object or Array Nesting Level"},{"location":"v2/validators/isbn/","text":"Isbn Validator Laminas\\Validator\\Isbn allows you to validate an ISBN-10 or ISBN-13 value. Supported options The following options are supported for Laminas\\Validator\\Isbn : separator : Defines the allowed separator for the ISBN number. It defaults to an empty string. type : Defines the allowed ISBN types. It defaults to Laminas\\Validator\\Isbn::AUTO . For details, take a look at the section on explicit types . Basic usage A basic example of usage is below: $validator = new Laminas\\Validator\\Isbn(); if ($validator-&gt;isValid($isbn)) { // isbn is valid } else { // isbn is not valid } This will validate any ISBN-10 and ISBN-13 without separator. Setting an explicit ISBN validation type An example of an ISBN type restriction follows: use Laminas\\Validator\\Isbn; $validator = new Isbn(); $validator-&gt;setType(Isbn::ISBN13); // OR $validator = new Isbn([ 'type' =&gt; Isbn::ISBN13]); if ($validator-&gt;isValid($isbn)) { // this is a valid ISBN-13 value } else { // this is an invalid ISBN-13 value } The above will validate only ISBN-13 values. Valid types include: Laminas\\Validator\\Isbn::AUTO (default) Laminas\\Validator\\Isbn::ISBN10 Laminas\\Validator\\Isbn::ISBN13 Specifying a separator restriction An example of separator restriction: $validator = new Laminas\\Validator\\Isbn(); $validator-&gt;setSeparator('-'); // OR $validator = new Laminas\\Validator\\Isbn(['separator' =&gt; '-']); if ($validator-&gt;isValid($isbn)) { // this is a valid ISBN with separator } else { // this is an invalid ISBN with separator } Values without separators This will return false if $isbn doesn't contain a separator or if it's an invalid ISBN value. Valid separators include: `` (empty) (default) - (hyphen) (space)","title":"Isbn"},{"location":"v2/validators/isbn/#isbn-validator","text":"Laminas\\Validator\\Isbn allows you to validate an ISBN-10 or ISBN-13 value.","title":"Isbn Validator"},{"location":"v2/validators/isbn/#supported-options","text":"The following options are supported for Laminas\\Validator\\Isbn : separator : Defines the allowed separator for the ISBN number. It defaults to an empty string. type : Defines the allowed ISBN types. It defaults to Laminas\\Validator\\Isbn::AUTO . For details, take a look at the section on explicit types .","title":"Supported options"},{"location":"v2/validators/isbn/#basic-usage","text":"A basic example of usage is below: $validator = new Laminas\\Validator\\Isbn(); if ($validator-&gt;isValid($isbn)) { // isbn is valid } else { // isbn is not valid } This will validate any ISBN-10 and ISBN-13 without separator.","title":"Basic usage"},{"location":"v2/validators/isbn/#setting-an-explicit-isbn-validation-type","text":"An example of an ISBN type restriction follows: use Laminas\\Validator\\Isbn; $validator = new Isbn(); $validator-&gt;setType(Isbn::ISBN13); // OR $validator = new Isbn([ 'type' =&gt; Isbn::ISBN13]); if ($validator-&gt;isValid($isbn)) { // this is a valid ISBN-13 value } else { // this is an invalid ISBN-13 value } The above will validate only ISBN-13 values. Valid types include: Laminas\\Validator\\Isbn::AUTO (default) Laminas\\Validator\\Isbn::ISBN10 Laminas\\Validator\\Isbn::ISBN13","title":"Setting an explicit ISBN validation type"},{"location":"v2/validators/isbn/#specifying-a-separator-restriction","text":"An example of separator restriction: $validator = new Laminas\\Validator\\Isbn(); $validator-&gt;setSeparator('-'); // OR $validator = new Laminas\\Validator\\Isbn(['separator' =&gt; '-']); if ($validator-&gt;isValid($isbn)) { // this is a valid ISBN with separator } else { // this is an invalid ISBN with separator }","title":"Specifying a separator restriction"},{"location":"v2/validators/isinstanceof/","text":"IsInstanceOf Validator Laminas\\Validator\\IsInstanceOf allows you to validate whether a given object is an instance of a specific class or interface. Supported options The following options are supported for Laminas\\Validator\\IsInstanceOf : className : Defines the fully-qualified class name which objects must be an instance of. Basic usage $validator = new Laminas\\Validator\\IsInstanceOf([ 'className' =&gt; 'Laminas\\Validator\\Digits' ]); $object = new Laminas\\Validator\\Digits(); if ($validator-&gt;isValid($object)) { // $object is an instance of Laminas\\Validator\\Digits } else { // false. You can use $validator-&gt;getMessages() to retrieve error messages } If a string argument is passed to the constructor of Laminas\\Validator\\IsInstanceOf , then that value will be used as the class name: use Laminas\\Validator\\Digits; use Laminas\\Validator\\IsInstanceOf; $validator = new IsInstanceOf(Digits::class); $object = new Digits(); if ($validator-&gt;isValid($object)) { // $object is an instance of Laminas\\Validator\\Digits } else { // false. You can use $validator-&gt;getMessages() to retrieve error messages }","title":"IsInstanceOf"},{"location":"v2/validators/isinstanceof/#isinstanceof-validator","text":"Laminas\\Validator\\IsInstanceOf allows you to validate whether a given object is an instance of a specific class or interface.","title":"IsInstanceOf Validator"},{"location":"v2/validators/isinstanceof/#supported-options","text":"The following options are supported for Laminas\\Validator\\IsInstanceOf : className : Defines the fully-qualified class name which objects must be an instance of.","title":"Supported options"},{"location":"v2/validators/isinstanceof/#basic-usage","text":"$validator = new Laminas\\Validator\\IsInstanceOf([ 'className' =&gt; 'Laminas\\Validator\\Digits' ]); $object = new Laminas\\Validator\\Digits(); if ($validator-&gt;isValid($object)) { // $object is an instance of Laminas\\Validator\\Digits } else { // false. You can use $validator-&gt;getMessages() to retrieve error messages } If a string argument is passed to the constructor of Laminas\\Validator\\IsInstanceOf , then that value will be used as the class name: use Laminas\\Validator\\Digits; use Laminas\\Validator\\IsInstanceOf; $validator = new IsInstanceOf(Digits::class); $object = new Digits(); if ($validator-&gt;isValid($object)) { // $object is an instance of Laminas\\Validator\\Digits } else { // false. You can use $validator-&gt;getMessages() to retrieve error messages }","title":"Basic usage"},{"location":"v2/validators/less-than/","text":"LessThan Validator Deprecated This validator is deprecated in favour of the NumberComparison validator and the DateComparison validator for validation of dates. This validator will be removed in version 3.0. Laminas\\Validator\\LessThan allows you to validate if a given value is less than a maximum value. Supports only number validation Laminas\\Validator\\LessThan supports only the validation of numbers. Strings or dates can not be validated with this validator. Supported options The following options are supported for Laminas\\Validator\\LessThan : inclusive : Defines if the validation is inclusive the maximum value or exclusive. It defaults to false . max : Sets the maximum allowed value. Basic usage To validate if a given value is less than a defined maximum: $valid = new Laminas\\Validator\\LessThan(['max' =&gt; 10]); $value = 12; $return = $valid-&gt;isValid($value); // returns false The above example returns true for all values lower than 10. Inclusive validation Sometimes it is useful to validate a value by including the maximum value: $valid = new Laminas\\Validator\\LessThan([ 'max' =&gt; 10, 'inclusive' =&gt; true, ]); $value = 10; $result = $valid-&gt;isValid($value); // returns true The example is identical to our first example, with the exception that we've specified that the maximum is inclusive. Now the value '10' is allowed and will return true .","title":"LessThan"},{"location":"v2/validators/less-than/#lessthan-validator","text":"Deprecated This validator is deprecated in favour of the NumberComparison validator and the DateComparison validator for validation of dates. This validator will be removed in version 3.0. Laminas\\Validator\\LessThan allows you to validate if a given value is less than a maximum value. Supports only number validation Laminas\\Validator\\LessThan supports only the validation of numbers. Strings or dates can not be validated with this validator.","title":"LessThan Validator"},{"location":"v2/validators/less-than/#supported-options","text":"The following options are supported for Laminas\\Validator\\LessThan : inclusive : Defines if the validation is inclusive the maximum value or exclusive. It defaults to false . max : Sets the maximum allowed value.","title":"Supported options"},{"location":"v2/validators/less-than/#basic-usage","text":"To validate if a given value is less than a defined maximum: $valid = new Laminas\\Validator\\LessThan(['max' =&gt; 10]); $value = 12; $return = $valid-&gt;isValid($value); // returns false The above example returns true for all values lower than 10.","title":"Basic usage"},{"location":"v2/validators/less-than/#inclusive-validation","text":"Sometimes it is useful to validate a value by including the maximum value: $valid = new Laminas\\Validator\\LessThan([ 'max' =&gt; 10, 'inclusive' =&gt; true, ]); $value = 10; $result = $valid-&gt;isValid($value); // returns true The example is identical to our first example, with the exception that we've specified that the maximum is inclusive. Now the value '10' is allowed and will return true .","title":"Inclusive validation"},{"location":"v2/validators/not-empty/","text":"NotEmpty Validator This validator allows you to validate if a given value is not empty. This is often useful when working with form elements or other user input, where you can use it to ensure required elements have values associated with them. Supported options The following options are supported for Laminas\\Validator\\NotEmpty : type : Sets the type of validation which will be processed; for details, see the section on specifying empty behavior . Default behaviour By default, this validator works differently than you would expect when you've worked with PHP's empty() operator. In particular, this validator will evaluate both the integer 0 and string '0' as empty. $valid = new Laminas\\Validator\\NotEmpty(); $value = ''; $result = $valid-&gt;isValid($value); // returns false Specifying empty behavior Some projects have differing opinions of what is considered an \"empty\" value: a string with only whitespace might be considered empty, or 0 may be considered non-empty (particularly for boolean sequences). To accommodate differing needs, Laminas\\Validator\\NotEmpty allows you to configure which types should be validated as empty and which not. The following types can be handled: boolean : Returns false when the boolean value is false . integer : Returns false when an integer 0 value is given. By default, this validation is not activate and returns true for any integer values. float : Returns false when a float 0.0 value is given. By default, this validation is not activate and returns true on any float values. string : Returns false when an empty string '' is given. zero : Returns false when the single character zero ( '0' ) is given. empty_array : Returns false when an empty array is given. null : Returns false when a null value is given. php : Returns false on wherever PHP's empty() would return true . space : Returns false when an string is given which contains only whitespace. object : Returns true . false will be returned when object is not allowed but an object is given. object_string : Returns false when an object is given and its __toString() method returns an empty string. object_count : Returns false when an object is given, it implements Countable , and its count is 0. all : Returns false on all above types. All other given values will return true per default. There are several ways to select which of the above types are validated. You can give one or multiple types and add them, you can provide an array, you can use constants, or you can provide a textual string. See the following examples: use Laminas\\Validator\\NotEmpty; // Returns false on 0 $validator = new NotEmpty(NotEmpty::INTEGER); // Returns false on 0 or '0' $validator = new NotEmpty( NotEmpty::INTEGER | NotEmpty::ZERO); // Returns false on 0 or '0' $validator = new NotEmpty([ NotEmpty::INTEGER, NotEmpty::ZERO ]); // Returns false on 0 or '0' $validator = new NotEmpty(['integer', 'zero']); You can also provide an instance of Traversable to set the desired types. To set types after instantiation, use the setType() method.","title":"NotEmpty"},{"location":"v2/validators/not-empty/#notempty-validator","text":"This validator allows you to validate if a given value is not empty. This is often useful when working with form elements or other user input, where you can use it to ensure required elements have values associated with them.","title":"NotEmpty Validator"},{"location":"v2/validators/not-empty/#supported-options","text":"The following options are supported for Laminas\\Validator\\NotEmpty : type : Sets the type of validation which will be processed; for details, see the section on specifying empty behavior .","title":"Supported options"},{"location":"v2/validators/not-empty/#default-behaviour","text":"By default, this validator works differently than you would expect when you've worked with PHP's empty() operator. In particular, this validator will evaluate both the integer 0 and string '0' as empty. $valid = new Laminas\\Validator\\NotEmpty(); $value = ''; $result = $valid-&gt;isValid($value); // returns false","title":"Default behaviour"},{"location":"v2/validators/not-empty/#specifying-empty-behavior","text":"Some projects have differing opinions of what is considered an \"empty\" value: a string with only whitespace might be considered empty, or 0 may be considered non-empty (particularly for boolean sequences). To accommodate differing needs, Laminas\\Validator\\NotEmpty allows you to configure which types should be validated as empty and which not. The following types can be handled: boolean : Returns false when the boolean value is false . integer : Returns false when an integer 0 value is given. By default, this validation is not activate and returns true for any integer values. float : Returns false when a float 0.0 value is given. By default, this validation is not activate and returns true on any float values. string : Returns false when an empty string '' is given. zero : Returns false when the single character zero ( '0' ) is given. empty_array : Returns false when an empty array is given. null : Returns false when a null value is given. php : Returns false on wherever PHP's empty() would return true . space : Returns false when an string is given which contains only whitespace. object : Returns true . false will be returned when object is not allowed but an object is given. object_string : Returns false when an object is given and its __toString() method returns an empty string. object_count : Returns false when an object is given, it implements Countable , and its count is 0. all : Returns false on all above types. All other given values will return true per default. There are several ways to select which of the above types are validated. You can give one or multiple types and add them, you can provide an array, you can use constants, or you can provide a textual string. See the following examples: use Laminas\\Validator\\NotEmpty; // Returns false on 0 $validator = new NotEmpty(NotEmpty::INTEGER); // Returns false on 0 or '0' $validator = new NotEmpty( NotEmpty::INTEGER | NotEmpty::ZERO); // Returns false on 0 or '0' $validator = new NotEmpty([ NotEmpty::INTEGER, NotEmpty::ZERO ]); // Returns false on 0 or '0' $validator = new NotEmpty(['integer', 'zero']); You can also provide an instance of Traversable to set the desired types. To set types after instantiation, use the setType() method.","title":"Specifying empty behavior"},{"location":"v2/validators/number-comparison/","text":"Number Comparison Validator Laminas\\Validator\\NumberComparison allows you to validate if a given value is a numeric value that is either: Between a min and max value Greater than a min value Less than a max value By default, comparisons are inclusive. Only supports number validation Laminas\\Validator\\NumberComparison supports only the validation of numbers. Strings or dates can not be validated with this validator. Supported Options The following options are supported for Laminas\\Validator\\NumberComparison : Option Data Type Default Value Description max numeric null Sets the upper bound for the input. min numeric null Sets the lower bound for the input. inclusiveMin bool true Defines if the validation is inclusive of the lower bound, or exclusive. inclusiveMax bool true Defines if the validation is inclusive of the upper bound, or exclusive. Basic Usage Per default, this validator checks if a value is between min and max where both upper and lower bounds are considered valid. $valid = new Laminas\\Validator\\NumberComparison(['min' =&gt; 0, 'max' =&gt; 10]); $value = 10; $result = $valid-&gt;isValid($value); // returns true In the above example, the result is true due to the reason that the default search is inclusive of the border values. This means in our case that any value from 0 to 10 is allowed; values like -1 and 11 will return false . Excluding Upper and Lower Bounds Sometimes it is useful to validate a value by excluding the bounds. See the following example: $valid = new Laminas\\Validator\\NumberComparison([ 'min' =&gt; 0, 'max' =&gt; 10, 'inclusiveMin' =&gt; false, 'inclusiveMax' =&gt; false, ]); $valid-&gt;isValid(10); // false $valid-&gt;isValid(0); // false $valid-&gt;isValid(9); // true The example above is almost identical to our first example, but we now exclude the bounds as valid values; as such, the values 0 and 10 are no longer allowed and will return false . Min and Max behaviour In order to validate a number that is simply greater than a lower bound, either omit the max option, or set it explicitly to null : $validator = new Laminas\\Validator\\NumberComparison(['min' =&gt; 10, 'max' =&gt; null]); $validator-&gt;isValid(12345); // true Conversely, to ensure a number is less than an upper bound, omit the min option or explicitly set it to null : $validator = new Laminas\\Validator\\NumberComparison(['max' =&gt; 5]); $validator-&gt;isValid(99); // false You must provide one of the min or the max (or both) options or an exception will be thrown. It doesn't make sense to compare the input to nothing for this validator.","title":"NumberComparison"},{"location":"v2/validators/number-comparison/#number-comparison-validator","text":"Laminas\\Validator\\NumberComparison allows you to validate if a given value is a numeric value that is either: Between a min and max value Greater than a min value Less than a max value By default, comparisons are inclusive. Only supports number validation Laminas\\Validator\\NumberComparison supports only the validation of numbers. Strings or dates can not be validated with this validator.","title":"Number Comparison Validator"},{"location":"v2/validators/number-comparison/#supported-options","text":"The following options are supported for Laminas\\Validator\\NumberComparison : Option Data Type Default Value Description max numeric null Sets the upper bound for the input. min numeric null Sets the lower bound for the input. inclusiveMin bool true Defines if the validation is inclusive of the lower bound, or exclusive. inclusiveMax bool true Defines if the validation is inclusive of the upper bound, or exclusive.","title":"Supported Options"},{"location":"v2/validators/number-comparison/#basic-usage","text":"Per default, this validator checks if a value is between min and max where both upper and lower bounds are considered valid. $valid = new Laminas\\Validator\\NumberComparison(['min' =&gt; 0, 'max' =&gt; 10]); $value = 10; $result = $valid-&gt;isValid($value); // returns true In the above example, the result is true due to the reason that the default search is inclusive of the border values. This means in our case that any value from 0 to 10 is allowed; values like -1 and 11 will return false .","title":"Basic Usage"},{"location":"v2/validators/number-comparison/#excluding-upper-and-lower-bounds","text":"Sometimes it is useful to validate a value by excluding the bounds. See the following example: $valid = new Laminas\\Validator\\NumberComparison([ 'min' =&gt; 0, 'max' =&gt; 10, 'inclusiveMin' =&gt; false, 'inclusiveMax' =&gt; false, ]); $valid-&gt;isValid(10); // false $valid-&gt;isValid(0); // false $valid-&gt;isValid(9); // true The example above is almost identical to our first example, but we now exclude the bounds as valid values; as such, the values 0 and 10 are no longer allowed and will return false .","title":"Excluding Upper and Lower Bounds"},{"location":"v2/validators/number-comparison/#min-and-max-behaviour","text":"In order to validate a number that is simply greater than a lower bound, either omit the max option, or set it explicitly to null : $validator = new Laminas\\Validator\\NumberComparison(['min' =&gt; 10, 'max' =&gt; null]); $validator-&gt;isValid(12345); // true Conversely, to ensure a number is less than an upper bound, omit the min option or explicitly set it to null : $validator = new Laminas\\Validator\\NumberComparison(['max' =&gt; 5]); $validator-&gt;isValid(99); // false You must provide one of the min or the max (or both) options or an exception will be thrown. It doesn't make sense to compare the input to nothing for this validator.","title":"Min and Max behaviour"},{"location":"v2/validators/regex/","text":"Regex Validator This validator allows you to validate if a given string conforms a defined regular expression. Supported options The following options are supported for Laminas\\Validator\\Regex : pattern : Sets the regular expression pattern for this validator. Usage Validation with regular expressions allows complex validations without writing a custom validator. $validator = new Laminas\\Validator\\Regex(['pattern' =&gt; '/^Test/']); $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns true $validator-&gt;isValid(\"Pest\"); // returns false The pattern uses the same syntax as preg_match() . For details about regular expressions take a look into PHP's manual about PCRE pattern syntax . Pattern handling It is also possible to set a different pattern afterwards by using setPattern() and to get the actual set pattern with getPattern() . $validator = new Laminas\\Validator\\Regex(['pattern' =&gt; '/^Test/']); $validator-&gt;setPattern('ing$/'); $validator-&gt;isValid(\"Test\"); // returns false $validator-&gt;isValid(\"Testing\"); // returns true $validator-&gt;isValid(\"Pest\"); // returns false","title":"Regex"},{"location":"v2/validators/regex/#regex-validator","text":"This validator allows you to validate if a given string conforms a defined regular expression.","title":"Regex Validator"},{"location":"v2/validators/regex/#supported-options","text":"The following options are supported for Laminas\\Validator\\Regex : pattern : Sets the regular expression pattern for this validator.","title":"Supported options"},{"location":"v2/validators/regex/#usage","text":"Validation with regular expressions allows complex validations without writing a custom validator. $validator = new Laminas\\Validator\\Regex(['pattern' =&gt; '/^Test/']); $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns true $validator-&gt;isValid(\"Pest\"); // returns false The pattern uses the same syntax as preg_match() . For details about regular expressions take a look into PHP's manual about PCRE pattern syntax .","title":"Usage"},{"location":"v2/validators/regex/#pattern-handling","text":"It is also possible to set a different pattern afterwards by using setPattern() and to get the actual set pattern with getPattern() . $validator = new Laminas\\Validator\\Regex(['pattern' =&gt; '/^Test/']); $validator-&gt;setPattern('ing$/'); $validator-&gt;isValid(\"Test\"); // returns false $validator-&gt;isValid(\"Testing\"); // returns true $validator-&gt;isValid(\"Pest\"); // returns false","title":"Pattern handling"},{"location":"v2/validators/sitemap/","text":"Sitemap Validators The following validators conform to the Sitemap XML protocol . Supported options There are no additional supported options for any of the Sitemap validators. Changefreq Laminas\\Validator\\Sitemap\\Changefreq validates whether a string is valid for using as a 'changefreq' element in a Sitemap XML document. Valid values are: 'always', 'hourly', 'daily', 'weekly', 'monthly', 'yearly', or 'never'. Returns true if and only if the value is a string and is equal to one of the frequencies specified above. Sitemap\\Lastmod Laminas\\Validator\\Sitemap\\Lastmod validates whether a string is valid for using as a 'lastmod' element in a Sitemap XML document. The lastmod element should contain a W3C date string, optionally discarding information about time. Returns true if and only if the given value is a string and is valid according to the protocol. $validator = new Laminas\\Validator\\Sitemap\\Lastmod(); $validator-&gt;isValid('1999-11-11T22:23:52-02:00'); // true $validator-&gt;isValid('2008-05-12T00:42:52+02:00'); // true $validator-&gt;isValid('1999-11-11'); // true $validator-&gt;isValid('2008-05-12'); // true $validator-&gt;isValid('1999-11-11t22:23:52-02:00'); // false $validator-&gt;isValid('2008-05-12T00:42:60+02:00'); // false $validator-&gt;isValid('1999-13-11'); // false $validator-&gt;isValid('2008-05-32'); // false $validator-&gt;isValid('yesterday'); // false Loc Laminas\\Validator\\Sitemap\\Loc validates whether a string is valid for using as a 'loc' element in a Sitemap XML document. This uses Laminas\\Uri\\Uri::isValid() internally. Installation requirements Laminas\\Validator\\Sitemap\\Loc depends on the laminas-uri component, so be sure to have it installed before getting started: $ composer require laminas/laminas-uri Priority Laminas\\Validator\\Sitemap\\Priority validates whether a value is valid for using as a 'priority' element in a Sitemap XML document. The value should be a decimal between 0.0 and 1.0. This validator accepts both numeric values and string values. $validator = new Laminas\\Validator\\Sitemap\\Priority(); $validator-&gt;isValid('0.1'); // true $validator-&gt;isValid('0.789'); // true $validator-&gt;isValid(0.8); // true $validator-&gt;isValid(1.0); // true $validator-&gt;isValid('1.1'); // false $validator-&gt;isValid('-0.4'); // false $validator-&gt;isValid(1.00001); // false $validator-&gt;isValid(0xFF); // false $validator-&gt;isValid('foo'); // false","title":"Sitemap"},{"location":"v2/validators/sitemap/#sitemap-validators","text":"The following validators conform to the Sitemap XML protocol .","title":"Sitemap Validators"},{"location":"v2/validators/sitemap/#supported-options","text":"There are no additional supported options for any of the Sitemap validators.","title":"Supported options"},{"location":"v2/validators/sitemap/#changefreq","text":"Laminas\\Validator\\Sitemap\\Changefreq validates whether a string is valid for using as a 'changefreq' element in a Sitemap XML document. Valid values are: 'always', 'hourly', 'daily', 'weekly', 'monthly', 'yearly', or 'never'. Returns true if and only if the value is a string and is equal to one of the frequencies specified above.","title":"Changefreq"},{"location":"v2/validators/sitemap/#sitemaplastmod","text":"Laminas\\Validator\\Sitemap\\Lastmod validates whether a string is valid for using as a 'lastmod' element in a Sitemap XML document. The lastmod element should contain a W3C date string, optionally discarding information about time. Returns true if and only if the given value is a string and is valid according to the protocol. $validator = new Laminas\\Validator\\Sitemap\\Lastmod(); $validator-&gt;isValid('1999-11-11T22:23:52-02:00'); // true $validator-&gt;isValid('2008-05-12T00:42:52+02:00'); // true $validator-&gt;isValid('1999-11-11'); // true $validator-&gt;isValid('2008-05-12'); // true $validator-&gt;isValid('1999-11-11t22:23:52-02:00'); // false $validator-&gt;isValid('2008-05-12T00:42:60+02:00'); // false $validator-&gt;isValid('1999-13-11'); // false $validator-&gt;isValid('2008-05-32'); // false $validator-&gt;isValid('yesterday'); // false","title":"Sitemap\\Lastmod"},{"location":"v2/validators/sitemap/#loc","text":"Laminas\\Validator\\Sitemap\\Loc validates whether a string is valid for using as a 'loc' element in a Sitemap XML document. This uses Laminas\\Uri\\Uri::isValid() internally.","title":"Loc"},{"location":"v2/validators/sitemap/#priority","text":"Laminas\\Validator\\Sitemap\\Priority validates whether a value is valid for using as a 'priority' element in a Sitemap XML document. The value should be a decimal between 0.0 and 1.0. This validator accepts both numeric values and string values. $validator = new Laminas\\Validator\\Sitemap\\Priority(); $validator-&gt;isValid('0.1'); // true $validator-&gt;isValid('0.789'); // true $validator-&gt;isValid(0.8); // true $validator-&gt;isValid(1.0); // true $validator-&gt;isValid('1.1'); // false $validator-&gt;isValid('-0.4'); // false $validator-&gt;isValid(1.00001); // false $validator-&gt;isValid(0xFF); // false $validator-&gt;isValid('foo'); // false","title":"Priority"},{"location":"v2/validators/step/","text":"Step Validator Laminas\\Validator\\Step allows you to validate if a given value is a valid step value. This validator requires the value to be a numeric value (either string, int or float). Supported options The following options are supported for Laminas\\Validator\\Step : baseValue : This is the base value from which the step should be computed. This option defaults to 0 step : This is the step value. This option defaults to 1 Basic usage $validator = new Laminas\\Validator\\Step(); if ($validator-&gt;isValid(1)) { // value is a valid step value } else { // false } Using floating-point values The Step validator also supports floating-point base and step values: $validator = new Laminas\\Validator\\Step([ 'baseValue' =&gt; 1.1, 'step' =&gt; 2.2, ]); echo $validator-&gt;isValid(1.1); // prints true echo $validator-&gt;isValid(3.3); // prints true echo $validator-&gt;isValid(3.35); // prints false echo $validator-&gt;isValid(2.2); // prints false","title":"Step"},{"location":"v2/validators/step/#step-validator","text":"Laminas\\Validator\\Step allows you to validate if a given value is a valid step value. This validator requires the value to be a numeric value (either string, int or float).","title":"Step Validator"},{"location":"v2/validators/step/#supported-options","text":"The following options are supported for Laminas\\Validator\\Step : baseValue : This is the base value from which the step should be computed. This option defaults to 0 step : This is the step value. This option defaults to 1","title":"Supported options"},{"location":"v2/validators/step/#basic-usage","text":"$validator = new Laminas\\Validator\\Step(); if ($validator-&gt;isValid(1)) { // value is a valid step value } else { // false }","title":"Basic usage"},{"location":"v2/validators/step/#using-floating-point-values","text":"The Step validator also supports floating-point base and step values: $validator = new Laminas\\Validator\\Step([ 'baseValue' =&gt; 1.1, 'step' =&gt; 2.2, ]); echo $validator-&gt;isValid(1.1); // prints true echo $validator-&gt;isValid(3.3); // prints true echo $validator-&gt;isValid(3.35); // prints false echo $validator-&gt;isValid(2.2); // prints false","title":"Using floating-point values"},{"location":"v2/validators/string-length/","text":"StringLength Validator This validator allows you to validate if a given string is between a defined length. Supports only string validation Laminas\\Validator\\StringLength supports only the validation of strings. Integers, floats, dates or objects can not be validated with this validator. Supported options The following options are supported for Laminas\\Validator\\StringLength : encoding : Sets the ICONV encoding to use with the string. min : Sets the minimum allowed length for a string. max : Sets the maximum allowed length for a string. Default behaviour By default, this validator checks if a value is between min and max using a default min value of 0 and default max value of NULL (meaning unlimited). As such, without any options, the validator only checks that the input is a string. Limiting the maximum string length To limit the maximum allowed length of a string you need to set the max property. It accepts an integer value as input. $validator = new Laminas\\Validator\\StringLength(['max' =&gt; 6]); $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns false You can set the maximum allowed length after instantiation by using the setMax() method; getMax() retrieves the value. $validator = new Laminas\\Validator\\StringLength(); $validator-&gt;setMax(6); $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns false Limiting the minimum string length To limit the minimal required string length, set the min property using an integer value: $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 5]); $validator-&gt;isValid(\"Test\"); // returns false $validator-&gt;isValid(\"Testing\"); // returns true You can set the value after instantiation using the setMin() method; getMin() retrieves the value. $validator = new Laminas\\Validator\\StringLength(); $validator-&gt;setMin(5); $validator-&gt;isValid(\"Test\"); // returns false $validator-&gt;isValid(\"Testing\"); // returns true Limiting both minimum and maximum string length Sometimes you will need to set both a minimum and a maximum string length; as an example, in a username input, you may want to limit the name to a maximum of 30 characters, but require at least three charcters: $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 3, 'max' =&gt; 30]); $validator-&gt;isValid(\".\"); // returns false $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns true Limiting to a strict length If you need a strict length, then set the min and max properties to the same value: $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 4, 'max' =&gt; 4]); $validator-&gt;isValid('Tes'); // returns false $validator-&gt;isValid('Test'); // returns true $validator-&gt;isValid('Testi'); // returns false Setting a maximum lower than the minimum When you try to set a lower maximum value than the specified minimum value, or a higher minimum value as the actual maximum value, the validator will raise an exception. Encoding of values Strings are always using a encoding. Even when you don't set the encoding explicitly, PHP uses one. When your application is using a different encoding than PHP itself, you should set an encoding manually. You can set an encoding at instantiation with the encoding option, or by using the setEncoding() method. We assume that your installation uses ISO and your application it set to ISO. In this case you will see the below behaviour. $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 6]); $validator-&gt;isValid(\"rger\"); // returns false $validator-&gt;setEncoding(\"UTF-8\"); $validator-&gt;isValid(\"rger\"); // returns true $validator2 = new Laminas\\Validator\\StringLength([ 'min' =&gt; 6, 'encoding' =&gt; 'UTF-8', ]); $validator2-&gt;isValid(\"rger\"); // returns true When your installation and your application are using different encodings, then you should always set an encoding manually. Validation Messages Using the setMessage() method you can set another message to be returned in case of the specified failure. $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 3, 'max' =&gt; 30]); $validator-&gt;setMessage('Youre string is too long. You typed '%length%' chars.', Laminas\\Validator\\StringLength::TOO_LONG);","title":"StringLength"},{"location":"v2/validators/string-length/#stringlength-validator","text":"This validator allows you to validate if a given string is between a defined length.","title":"StringLength Validator"},{"location":"v2/validators/string-length/#supported-options","text":"The following options are supported for Laminas\\Validator\\StringLength : encoding : Sets the ICONV encoding to use with the string. min : Sets the minimum allowed length for a string. max : Sets the maximum allowed length for a string.","title":"Supported options"},{"location":"v2/validators/string-length/#default-behaviour","text":"By default, this validator checks if a value is between min and max using a default min value of 0 and default max value of NULL (meaning unlimited). As such, without any options, the validator only checks that the input is a string.","title":"Default behaviour"},{"location":"v2/validators/string-length/#limiting-the-maximum-string-length","text":"To limit the maximum allowed length of a string you need to set the max property. It accepts an integer value as input. $validator = new Laminas\\Validator\\StringLength(['max' =&gt; 6]); $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns false You can set the maximum allowed length after instantiation by using the setMax() method; getMax() retrieves the value. $validator = new Laminas\\Validator\\StringLength(); $validator-&gt;setMax(6); $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns false","title":"Limiting the maximum string length"},{"location":"v2/validators/string-length/#limiting-the-minimum-string-length","text":"To limit the minimal required string length, set the min property using an integer value: $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 5]); $validator-&gt;isValid(\"Test\"); // returns false $validator-&gt;isValid(\"Testing\"); // returns true You can set the value after instantiation using the setMin() method; getMin() retrieves the value. $validator = new Laminas\\Validator\\StringLength(); $validator-&gt;setMin(5); $validator-&gt;isValid(\"Test\"); // returns false $validator-&gt;isValid(\"Testing\"); // returns true","title":"Limiting the minimum string length"},{"location":"v2/validators/string-length/#limiting-both-minimum-and-maximum-string-length","text":"Sometimes you will need to set both a minimum and a maximum string length; as an example, in a username input, you may want to limit the name to a maximum of 30 characters, but require at least three charcters: $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 3, 'max' =&gt; 30]); $validator-&gt;isValid(\".\"); // returns false $validator-&gt;isValid(\"Test\"); // returns true $validator-&gt;isValid(\"Testing\"); // returns true","title":"Limiting both minimum and maximum string length"},{"location":"v2/validators/string-length/#limiting-to-a-strict-length","text":"If you need a strict length, then set the min and max properties to the same value: $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 4, 'max' =&gt; 4]); $validator-&gt;isValid('Tes'); // returns false $validator-&gt;isValid('Test'); // returns true $validator-&gt;isValid('Testi'); // returns false","title":"Limiting to a strict length"},{"location":"v2/validators/string-length/#encoding-of-values","text":"Strings are always using a encoding. Even when you don't set the encoding explicitly, PHP uses one. When your application is using a different encoding than PHP itself, you should set an encoding manually. You can set an encoding at instantiation with the encoding option, or by using the setEncoding() method. We assume that your installation uses ISO and your application it set to ISO. In this case you will see the below behaviour. $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 6]); $validator-&gt;isValid(\"rger\"); // returns false $validator-&gt;setEncoding(\"UTF-8\"); $validator-&gt;isValid(\"rger\"); // returns true $validator2 = new Laminas\\Validator\\StringLength([ 'min' =&gt; 6, 'encoding' =&gt; 'UTF-8', ]); $validator2-&gt;isValid(\"rger\"); // returns true When your installation and your application are using different encodings, then you should always set an encoding manually.","title":"Encoding of values"},{"location":"v2/validators/string-length/#validation-messages","text":"Using the setMessage() method you can set another message to be returned in case of the specified failure. $validator = new Laminas\\Validator\\StringLength(['min' =&gt; 3, 'max' =&gt; 30]); $validator-&gt;setMessage('Youre string is too long. You typed '%length%' chars.', Laminas\\Validator\\StringLength::TOO_LONG);","title":"Validation Messages"},{"location":"v2/validators/timezone/","text":"Timezone Validator Laminas\\Validator\\Timezone allows validating if an input string represents a timezone. Supported validation types The Laminas\\Validator\\Timezone validator is capable of validating the abbreviation (e.g. ewt ) as well as the location string (e.g. America/Los_Angeles ). These options are stored in the validator as LOCATION , ABBREVIATION , and ALL class constants. Basic Usage The default validation type will check against abbreviations as well as the location string. $validator = new Laminas\\Validator\\Timezone(); $validator-&gt;isValid('America/Los_Angeles'); // returns true $validator-&gt;isValid('ewt'); // returns true $validator-&gt;isValid('Foobar'); // returns false To validate against only the location string you can set the type: use Laminas\\Validator\\Timezone; $validator = new Timezone(); $validator-&gt;setType(Timezone::LOCATION); $validator-&gt;isValid('America/Los_Angeles'); // returns true $validator-&gt;isValid('ewt'); // returns false $validator-&gt;isValid('Foobar'); // returns false","title":"Timezone"},{"location":"v2/validators/timezone/#timezone-validator","text":"Laminas\\Validator\\Timezone allows validating if an input string represents a timezone.","title":"Timezone Validator"},{"location":"v2/validators/timezone/#supported-validation-types","text":"The Laminas\\Validator\\Timezone validator is capable of validating the abbreviation (e.g. ewt ) as well as the location string (e.g. America/Los_Angeles ). These options are stored in the validator as LOCATION , ABBREVIATION , and ALL class constants.","title":"Supported validation types"},{"location":"v2/validators/timezone/#basic-usage","text":"The default validation type will check against abbreviations as well as the location string. $validator = new Laminas\\Validator\\Timezone(); $validator-&gt;isValid('America/Los_Angeles'); // returns true $validator-&gt;isValid('ewt'); // returns true $validator-&gt;isValid('Foobar'); // returns false To validate against only the location string you can set the type: use Laminas\\Validator\\Timezone; $validator = new Timezone(); $validator-&gt;setType(Timezone::LOCATION); $validator-&gt;isValid('America/Los_Angeles'); // returns true $validator-&gt;isValid('ewt'); // returns false $validator-&gt;isValid('Foobar'); // returns false","title":"Basic Usage"},{"location":"v2/validators/undisclosed-password/","text":"Undisclosed Password Validator Since 2.13.0 Laminas\\Validator\\UndisclosedPassword allows you to validate if a given password was found in data breaches using the service Have I Been Pwned? , in a secure, anonymous way using K-Anonymity to ensure passwords are not send in full over the wire. Installation requirements This validator needs to make a request over HTTP; therefore it requires an HTTP client. The validator provides support only for HTTP clients implementing PSR-18 and PSR-17 request and response factories. To ensure you have these installed before using this validator, run the following: $ composer require psr/http-client $ composer require psr/http-factory Basic usage The validator has two required constructor arguments: an HTTP Client that implements Psr\\Http\\Client\\ClientInterface a Psr\\Http\\Message\\RequestFactoryInterface instance Once you have an instance, you can then pass a password to its isValid() method to determine if it has been disclosed in a known data breach. If the password was found via the service, isValid() will return false . If the password was not found, isValid() will return true . $validator = new Laminas\\Validator\\UndisclosedPassword( $httpClient, // a PSR-18 HttpClientInterface $requestFactory // a PSR-17 RequestFactoryInterface ); $result = $validator-&gt;isValid('password'); // $result is FALSE because \"password\" was found in a data breach $result = $validator-&gt;isValid('8aDk=XiW2E.77tLfuAcB'); // $result is TRUE because \"8aDk=XiW2E.77tLfuAcB\" was not found in a data breach A simple command line example In this example, I'm using laminas/laminas-diactoros to provide HTTP messages, and php-http/curl-client as the HTTP client. Let's begin with installation of all required packages: $ composer require \\ php-http/message \\ php-http/message-factory \\ php-http/discovery \\ php-http/curl-client \\ laminas/laminas-diactoros \\ laminas/laminas-validator Next, I create a file, undisclosed.php , where I put my code: require_once __DIR__ . '/vendor/autoload.php'; use Http\\Client\\Curl\\Client; use Laminas\\Diactoros\\RequestFactory; use Laminas\\Diactoros\\ResponseFactory; use Laminas\\Validator\\UndisclosedPassword; $requestFactory = new RequestFactory(); $responseFactory = new ResponseFactory(); $client = new Client($responseFactory, null); $undisclosedPassword = new UndisclosedPassword($client, $requestFactory); echo 'Password \"password\" is ' . ($undisclosedPassword-&gt;isValid('password') ? 'not disclosed' : 'disclosed') . PHP_EOL; echo 'Password \"NVt3MpvQ\" is ' . ($undisclosedPassword-&gt;isValid('NVt3MpvQ') ? 'not disclosed' : 'disclosed') . PHP_EOL; To run it, I use the PHP command line interpreter: $ php undisclosed.php And it gives me the following output: Password \"password\" is disclosed Password \"NVt3MpvQ\" is not disclosed","title":"UndisclosedPassword"},{"location":"v2/validators/undisclosed-password/#undisclosed-password-validator","text":"Since 2.13.0 Laminas\\Validator\\UndisclosedPassword allows you to validate if a given password was found in data breaches using the service Have I Been Pwned? , in a secure, anonymous way using K-Anonymity to ensure passwords are not send in full over the wire.","title":"Undisclosed Password Validator"},{"location":"v2/validators/undisclosed-password/#basic-usage","text":"The validator has two required constructor arguments: an HTTP Client that implements Psr\\Http\\Client\\ClientInterface a Psr\\Http\\Message\\RequestFactoryInterface instance Once you have an instance, you can then pass a password to its isValid() method to determine if it has been disclosed in a known data breach. If the password was found via the service, isValid() will return false . If the password was not found, isValid() will return true . $validator = new Laminas\\Validator\\UndisclosedPassword( $httpClient, // a PSR-18 HttpClientInterface $requestFactory // a PSR-17 RequestFactoryInterface ); $result = $validator-&gt;isValid('password'); // $result is FALSE because \"password\" was found in a data breach $result = $validator-&gt;isValid('8aDk=XiW2E.77tLfuAcB'); // $result is TRUE because \"8aDk=XiW2E.77tLfuAcB\" was not found in a data breach","title":"Basic usage"},{"location":"v2/validators/undisclosed-password/#a-simple-command-line-example","text":"In this example, I'm using laminas/laminas-diactoros to provide HTTP messages, and php-http/curl-client as the HTTP client. Let's begin with installation of all required packages: $ composer require \\ php-http/message \\ php-http/message-factory \\ php-http/discovery \\ php-http/curl-client \\ laminas/laminas-diactoros \\ laminas/laminas-validator Next, I create a file, undisclosed.php , where I put my code: require_once __DIR__ . '/vendor/autoload.php'; use Http\\Client\\Curl\\Client; use Laminas\\Diactoros\\RequestFactory; use Laminas\\Diactoros\\ResponseFactory; use Laminas\\Validator\\UndisclosedPassword; $requestFactory = new RequestFactory(); $responseFactory = new ResponseFactory(); $client = new Client($responseFactory, null); $undisclosedPassword = new UndisclosedPassword($client, $requestFactory); echo 'Password \"password\" is ' . ($undisclosedPassword-&gt;isValid('password') ? 'not disclosed' : 'disclosed') . PHP_EOL; echo 'Password \"NVt3MpvQ\" is ' . ($undisclosedPassword-&gt;isValid('NVt3MpvQ') ? 'not disclosed' : 'disclosed') . PHP_EOL; To run it, I use the PHP command line interpreter: $ php undisclosed.php And it gives me the following output: Password \"password\" is disclosed Password \"NVt3MpvQ\" is not disclosed","title":"A simple command line example"},{"location":"v2/validators/uri/","text":"Uri Validator Laminas\\Validator\\Uri allows you to validate a URI using the Laminas\\Uri\\Uri handler to parse the URI. The validator allows for both validation of absolute and/or relative URIs. There is the possibility to exchange the handler for another one in case the parsing of the uri should be done differently. Installation Requirements The default handler depends on laminas-uri to parse the URI, so be sure to have it installed before getting started: composer require laminas/laminas-uri Supported options The following options are supported for Laminas\\Validator\\Uri : uriHandler : Defines the handler to be used to parse the uri. This options defaults to a new instance of Laminas\\Uri\\Uri . allowRelative : Defines if relative paths are allowed. This option defaults to true . allowAbsolute : Defines if absolute paths are allowed. This option defaults to true . Basic usage $validator = new Laminas\\Validator\\Uri(); $uri = 'https://getlaminas.org/manual'; if ($validator-&gt;isValid($uri)) { // $uri was valid } else { // false. You can use $validator-&gt;getMessages() to retrieve error messages }","title":"Uri"},{"location":"v2/validators/uri/#uri-validator","text":"Laminas\\Validator\\Uri allows you to validate a URI using the Laminas\\Uri\\Uri handler to parse the URI. The validator allows for both validation of absolute and/or relative URIs. There is the possibility to exchange the handler for another one in case the parsing of the uri should be done differently. Installation Requirements The default handler depends on laminas-uri to parse the URI, so be sure to have it installed before getting started: composer require laminas/laminas-uri","title":"Uri Validator"},{"location":"v2/validators/uri/#supported-options","text":"The following options are supported for Laminas\\Validator\\Uri : uriHandler : Defines the handler to be used to parse the uri. This options defaults to a new instance of Laminas\\Uri\\Uri . allowRelative : Defines if relative paths are allowed. This option defaults to true . allowAbsolute : Defines if absolute paths are allowed. This option defaults to true .","title":"Supported options"},{"location":"v2/validators/uri/#basic-usage","text":"$validator = new Laminas\\Validator\\Uri(); $uri = 'https://getlaminas.org/manual'; if ($validator-&gt;isValid($uri)) { // $uri was valid } else { // false. You can use $validator-&gt;getMessages() to retrieve error messages }","title":"Basic usage"},{"location":"v2/validators/uuid/","text":"UUID Validator Laminas\\Validator\\Uuid allows validating Universally Unique IDentifiers (UUIDs). UUIDs are 128-bit values that are guaranteed to be \"practically unique\" in order to help prevent identifier conflicts. Five separate UUID versions exist: Version 1, which uses a combination of date-time and hardware MAC addresses to generate the hash. Version 2, which uses a combination of date-time and system user/group identifiers. Version 3, which uses an MD5sum of a URI or distinguished name to generate the hash. Version 4, which uses a CSPRNG to generate the hash. Version 5, which uses the same idea as Version 3, but using SHA-1 for hashing. The Uuid validator is capable of validating whether a string is a valid UUID of any version. It does not validate that the UUID exists in your system, however, only that it is well-formed. Introduced in 2.8.0 Laminas\\Validator\\Uuid was introduced with version 2.8.0. Supported options The Uuid validator has no additional options. Basic usage $validator = new Laminas\\Validator\\Uuid(); if ($validator-&gt;isValid($uuid)) { // UUID was valid } else { // Invalid/mal-formed UUID; use $validator-&gt;getMessages() for more detail }","title":"Uuid"},{"location":"v2/validators/uuid/#uuid-validator","text":"Laminas\\Validator\\Uuid allows validating Universally Unique IDentifiers (UUIDs). UUIDs are 128-bit values that are guaranteed to be \"practically unique\" in order to help prevent identifier conflicts. Five separate UUID versions exist: Version 1, which uses a combination of date-time and hardware MAC addresses to generate the hash. Version 2, which uses a combination of date-time and system user/group identifiers. Version 3, which uses an MD5sum of a URI or distinguished name to generate the hash. Version 4, which uses a CSPRNG to generate the hash. Version 5, which uses the same idea as Version 3, but using SHA-1 for hashing. The Uuid validator is capable of validating whether a string is a valid UUID of any version. It does not validate that the UUID exists in your system, however, only that it is well-formed.","title":"UUID Validator"},{"location":"v2/validators/uuid/#supported-options","text":"The Uuid validator has no additional options.","title":"Supported options"},{"location":"v2/validators/uuid/#basic-usage","text":"$validator = new Laminas\\Validator\\Uuid(); if ($validator-&gt;isValid($uuid)) { // UUID was valid } else { // Invalid/mal-formed UUID; use $validator-&gt;getMessages() for more detail }","title":"Basic usage"},{"location":"v2/validators/file/count/","text":"Count Laminas\\Validator\\File\\Count allows you to validate that the number of files uploaded matches criteria, including a minimum number of files and/or a maximum number of files. Supported Options The following options are supported: min : The minimum number of uploaded files acceptable; null is equivalent to 0 , indicating no minimum. max : The maximum number of uploaded files acceptable; null is equivalent to no maximum. Basic Usage $validator = new Laminas\\Validator\\File\\Count([ 'min' =&gt; 1, 'max' =&gt; 5, ]); // Setting to the $_FILES superglobal; could also use the laminas-http // request's `getFiles()` or PSR-7 ServerRequest's `getUploadedFiles()`. $files = $_FILES; if ($validator-&gt;isValid($files)) { // Received between 1 and 5 files! }","title":"Count"},{"location":"v2/validators/file/count/#count","text":"Laminas\\Validator\\File\\Count allows you to validate that the number of files uploaded matches criteria, including a minimum number of files and/or a maximum number of files.","title":"Count"},{"location":"v2/validators/file/count/#supported-options","text":"The following options are supported: min : The minimum number of uploaded files acceptable; null is equivalent to 0 , indicating no minimum. max : The maximum number of uploaded files acceptable; null is equivalent to no maximum.","title":"Supported Options"},{"location":"v2/validators/file/count/#basic-usage","text":"$validator = new Laminas\\Validator\\File\\Count([ 'min' =&gt; 1, 'max' =&gt; 5, ]); // Setting to the $_FILES superglobal; could also use the laminas-http // request's `getFiles()` or PSR-7 ServerRequest's `getUploadedFiles()`. $files = $_FILES; if ($validator-&gt;isValid($files)) { // Received between 1 and 5 files! }","title":"Basic Usage"},{"location":"v2/validators/file/crc32/","text":"Crc32 Laminas\\Validator\\File\\Crc32 allows you to validate if a given file's hashed contents matches the supplied crc32 hash(es). It is subclassed from the Hash validator to provide a validator that only supports the crc32 algorithm. Requires the hash extension This validator requires the PHP Hash extension with the crc32 algorithm. Supported Options The following options are supported: hash : Single string hash to test the file against, or array of filename/hash pairs. Usage Examples // Does file have the given hash? $validator = new \\Laminas\\Validator\\File\\Crc32('3b3652f'); // Or, check file against multiple hashes $validator = new \\Laminas\\Validator\\File\\Crc32(['3b3652f', 'e612b69']); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid } Public Methods getCrc32 getCrc32() : array Returns an array of all currently registered hashes to test against. addCrc32 addCrc32(string|array $options) : void Add a single hash to test against, or a set of filename/hash pairs to test against. setCrc32 setCrc32(string|array $options): void Overwrite the current list of registered hashes with the one(s) provided.","title":"Crc32"},{"location":"v2/validators/file/crc32/#crc32","text":"Laminas\\Validator\\File\\Crc32 allows you to validate if a given file's hashed contents matches the supplied crc32 hash(es). It is subclassed from the Hash validator to provide a validator that only supports the crc32 algorithm.","title":"Crc32"},{"location":"v2/validators/file/crc32/#supported-options","text":"The following options are supported: hash : Single string hash to test the file against, or array of filename/hash pairs.","title":"Supported Options"},{"location":"v2/validators/file/crc32/#usage-examples","text":"// Does file have the given hash? $validator = new \\Laminas\\Validator\\File\\Crc32('3b3652f'); // Or, check file against multiple hashes $validator = new \\Laminas\\Validator\\File\\Crc32(['3b3652f', 'e612b69']); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"Usage Examples"},{"location":"v2/validators/file/crc32/#public-methods","text":"","title":"Public Methods"},{"location":"v2/validators/file/exclude-extension/","text":"ExcludeExtension Laminas\\Validator\\File\\ExcludeExtension checks the extension of files. It will assert false when a given file matches any of the defined extensions. This validator is inversely related to the Extension validator ; please refer to that validator for full options and usage examples.","title":"ExcludeExtension"},{"location":"v2/validators/file/exclude-extension/#excludeextension","text":"Laminas\\Validator\\File\\ExcludeExtension checks the extension of files. It will assert false when a given file matches any of the defined extensions. This validator is inversely related to the Extension validator ; please refer to that validator for full options and usage examples.","title":"ExcludeExtension"},{"location":"v2/validators/file/exclude-mime-type/","text":"ExcludeMimeType Laminas\\Validator\\File\\ExcludeMimeType checks the MIME type of files. It will assert false when a given file matches any of the defined MIME types. This validator is inversely related to the MimeType validator ; please refer to that validator's documentation for full options and usage examples.","title":"ExcludeMimeType"},{"location":"v2/validators/file/exclude-mime-type/#excludemimetype","text":"Laminas\\Validator\\File\\ExcludeMimeType checks the MIME type of files. It will assert false when a given file matches any of the defined MIME types. This validator is inversely related to the MimeType validator ; please refer to that validator's documentation for full options and usage examples.","title":"ExcludeMimeType"},{"location":"v2/validators/file/exists/","text":"Exists Laminas\\Validator\\File\\Exists checks for the existence of files in specified directories. This validator is inversely related to the NotExists validator . Supported Options The following set of options are supported: directory : Array of directories, or comma-delimited string of directories. Usage Examples use Laminas\\Validator\\File\\Exists; // Only allow files that exist in ~both~ directories $validator = new Exists('/tmp,/var/tmp'); // ...or with array notation $validator = new Exists(['/tmp', '/var/tmp']); // Perform validation if ($validator-&gt;isValid('/tmp/myfile.txt')) { // file is valid } Checks against all directories This validator checks whether the specified file exists in all of the given directories; validation will fail if the file does not exist in one or more of them.","title":"Exists"},{"location":"v2/validators/file/exists/#exists","text":"Laminas\\Validator\\File\\Exists checks for the existence of files in specified directories. This validator is inversely related to the NotExists validator .","title":"Exists"},{"location":"v2/validators/file/exists/#supported-options","text":"The following set of options are supported: directory : Array of directories, or comma-delimited string of directories.","title":"Supported Options"},{"location":"v2/validators/file/exists/#usage-examples","text":"use Laminas\\Validator\\File\\Exists; // Only allow files that exist in ~both~ directories $validator = new Exists('/tmp,/var/tmp'); // ...or with array notation $validator = new Exists(['/tmp', '/var/tmp']); // Perform validation if ($validator-&gt;isValid('/tmp/myfile.txt')) { // file is valid }","title":"Usage Examples"},{"location":"v2/validators/file/extension/","text":"Extension Laminas\\Validator\\File\\Extension checks the extension of files. It will assert true when a given file matches any of the defined extensions. This validator is inversely related to the ExcludeExtension validator . Supported Options The following set of options are supported: extension : Array of extensions, or comma-delimited string of extensions, against which to test. case : Boolean indicating whether or not extensions should match case sensitively; defaults to false (case-insensitive). allowNonExistentFile : ( Since 2.13.0 ) Boolean indicating whether or not to allow validating a filename for a non-existent file. Defaults to false (will not validate non-existent files). Usage Examples use Laminas\\Validator\\File\\Extension; // Allow files with 'php' or 'exe' extensions $validator = new Extension('php,exe'); // ...or with array notation $validator = new Extension(['php', 'exe']); // Test with case-sensitivity on $validator = new Extension(['php', 'exe'], true); // Using an options array: $validator = new Extension([ 'extension' =&gt; ['php', 'exe'], 'case' =&gt; true, ]); // Perform validation if ($validator-&gt;isValid('./myfile.php')) { // file is valid } Public Methods addExtension addExtension(string|array $options) : void Add one or more extensions as a comma-separated list, or as an array.","title":"Extension"},{"location":"v2/validators/file/extension/#extension","text":"Laminas\\Validator\\File\\Extension checks the extension of files. It will assert true when a given file matches any of the defined extensions. This validator is inversely related to the ExcludeExtension validator .","title":"Extension"},{"location":"v2/validators/file/extension/#supported-options","text":"The following set of options are supported: extension : Array of extensions, or comma-delimited string of extensions, against which to test. case : Boolean indicating whether or not extensions should match case sensitively; defaults to false (case-insensitive). allowNonExistentFile : ( Since 2.13.0 ) Boolean indicating whether or not to allow validating a filename for a non-existent file. Defaults to false (will not validate non-existent files).","title":"Supported Options"},{"location":"v2/validators/file/extension/#usage-examples","text":"use Laminas\\Validator\\File\\Extension; // Allow files with 'php' or 'exe' extensions $validator = new Extension('php,exe'); // ...or with array notation $validator = new Extension(['php', 'exe']); // Test with case-sensitivity on $validator = new Extension(['php', 'exe'], true); // Using an options array: $validator = new Extension([ 'extension' =&gt; ['php', 'exe'], 'case' =&gt; true, ]); // Perform validation if ($validator-&gt;isValid('./myfile.php')) { // file is valid }","title":"Usage Examples"},{"location":"v2/validators/file/extension/#public-methods","text":"","title":"Public Methods"},{"location":"v2/validators/file/files-size/","text":"FilesSize Laminas\\Validator\\File\\FilesSize allows validating the total size of all file uploads in aggregate, allowing specifying a minimum upload size and/or a maximum upload size. Only use this validator if you will be expecting multiple file uploads in a single payload, and want to ensure the aggregate size falls within a specific range. Supported Options Laminas\\Validator\\File\\FilesSize supports the following options: min : The minimum aggregate size of all file uploads. May be specified as an integer or using SI units. null indicates no minimum size is required. max : The maximum aggregate size of all file uploads. May be specified as an integer or using SI units. null indicates no maximum size is required. useByteString : A flag indicating whether sizes should be reported as integers or using SI units when reporting validation errors. See the Size validator for details on supported SI units. Basic Usage use Laminas\\Validator\\File\\FilesSize; $validator = new FilesSize([ 'min' =&gt; '1kB', // minimum of 1kB 'max' =&gt; '10MB', // maximum of 10MB ]); if ($validator-&gt;isValid($_FILES)) { // &gt; 1kB, &lt; 10MB in aggregate }","title":"FilesSize"},{"location":"v2/validators/file/files-size/#filessize","text":"Laminas\\Validator\\File\\FilesSize allows validating the total size of all file uploads in aggregate, allowing specifying a minimum upload size and/or a maximum upload size. Only use this validator if you will be expecting multiple file uploads in a single payload, and want to ensure the aggregate size falls within a specific range.","title":"FilesSize"},{"location":"v2/validators/file/files-size/#supported-options","text":"Laminas\\Validator\\File\\FilesSize supports the following options: min : The minimum aggregate size of all file uploads. May be specified as an integer or using SI units. null indicates no minimum size is required. max : The maximum aggregate size of all file uploads. May be specified as an integer or using SI units. null indicates no maximum size is required. useByteString : A flag indicating whether sizes should be reported as integers or using SI units when reporting validation errors. See the Size validator for details on supported SI units.","title":"Supported Options"},{"location":"v2/validators/file/files-size/#basic-usage","text":"use Laminas\\Validator\\File\\FilesSize; $validator = new FilesSize([ 'min' =&gt; '1kB', // minimum of 1kB 'max' =&gt; '10MB', // maximum of 10MB ]); if ($validator-&gt;isValid($_FILES)) { // &gt; 1kB, &lt; 10MB in aggregate }","title":"Basic Usage"},{"location":"v2/validators/file/hash/","text":"Hash Laminas\\Validator\\File\\Hash allows you to validate if a given file's hashed contents matches the supplied hash(es) and algorithm(s). Requires the hash extension This validator requires the PHP Hash extension . A list of supported hash algorithms can be found with the hash_algos() function . Supported Options The following set of options are supported: hash : String hash or array of hashes against which to test. algorithm : String hashing algorithm to use; defaults to crc32 Basic Usage use Laminas\\Validator\\File\\Hash; // Does file have the given hash? $validator = new Hash('3b3652f', 'crc32'); // Or, check file against multiple hashes $validator = new Hash(['3b3652f', 'e612b69'], 'crc32'); // Or use options notation: $validator = new Hash([ 'hash' =&gt; ['3b3652f', 'e612b69'], 'algorithm' =&gt; 'crc32', ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid } Public Methods getHash getHash() : array Returns an array containing the set of hashes against which to validate. addHash addHash(string|array $options) : void Add one or more hashes against which to validate. setHash setHash(string|array $options) : void Overwrite the current set of hashes with those provided to the method.","title":"Hash"},{"location":"v2/validators/file/hash/#hash","text":"Laminas\\Validator\\File\\Hash allows you to validate if a given file's hashed contents matches the supplied hash(es) and algorithm(s).","title":"Hash"},{"location":"v2/validators/file/hash/#supported-options","text":"The following set of options are supported: hash : String hash or array of hashes against which to test. algorithm : String hashing algorithm to use; defaults to crc32","title":"Supported Options"},{"location":"v2/validators/file/hash/#basic-usage","text":"use Laminas\\Validator\\File\\Hash; // Does file have the given hash? $validator = new Hash('3b3652f', 'crc32'); // Or, check file against multiple hashes $validator = new Hash(['3b3652f', 'e612b69'], 'crc32'); // Or use options notation: $validator = new Hash([ 'hash' =&gt; ['3b3652f', 'e612b69'], 'algorithm' =&gt; 'crc32', ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/hash/#public-methods","text":"","title":"Public Methods"},{"location":"v2/validators/file/image-size/","text":"ImageSize Laminas\\Validator\\File\\ImageSize checks the size of image files. Minimum and/or maximum dimensions can be set to validate against. Supported Options The following set of options are supported: minWidth : Set the minimum image width as an integer; null (the default) indicates no minimum. minHeight : Set the minimum image height as an integer; null (the default) indicates no minimum. maxWidth : Set the maximum image width as an integer; null (the default) indicates no maximum. maxHeight : Set the maximum image height as an integer; null (the default) indicates no maximum. Basic Usage use Laminas\\Validator\\File\\ImageSize; // Is image size between 320x200 (min) and 640x480 (max)? $validator = new ImageSize(320, 200, 640, 480); // ...or with array notation $validator = new ImageSize([ 'minWidth' =&gt; 320, 'minHeight' =&gt; 200, 'maxWidth' =&gt; 640, 'maxHeight' =&gt; 480, ]); // Is image size equal to or larger than 320x200? $validator = new ImageSize([ 'minWidth' =&gt; 320, 'minHeight' =&gt; 200, ]); // Is image size equal to or smaller than 640x480? $validator = new ImageSize([ 'maxWidth' =&gt; 640, 'maxHeight' =&gt; 480, ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.jpg')) { // file is valid } Public Methods getImageMin getImageMin() : array Returns the minimum valid dimensions as an array with the keys width and height . getImageMax getImageMax() : array Returns the maximum valid dimensions as an array with the keys width and height .","title":"ImageSize"},{"location":"v2/validators/file/image-size/#imagesize","text":"Laminas\\Validator\\File\\ImageSize checks the size of image files. Minimum and/or maximum dimensions can be set to validate against.","title":"ImageSize"},{"location":"v2/validators/file/image-size/#supported-options","text":"The following set of options are supported: minWidth : Set the minimum image width as an integer; null (the default) indicates no minimum. minHeight : Set the minimum image height as an integer; null (the default) indicates no minimum. maxWidth : Set the maximum image width as an integer; null (the default) indicates no maximum. maxHeight : Set the maximum image height as an integer; null (the default) indicates no maximum.","title":"Supported Options"},{"location":"v2/validators/file/image-size/#basic-usage","text":"use Laminas\\Validator\\File\\ImageSize; // Is image size between 320x200 (min) and 640x480 (max)? $validator = new ImageSize(320, 200, 640, 480); // ...or with array notation $validator = new ImageSize([ 'minWidth' =&gt; 320, 'minHeight' =&gt; 200, 'maxWidth' =&gt; 640, 'maxHeight' =&gt; 480, ]); // Is image size equal to or larger than 320x200? $validator = new ImageSize([ 'minWidth' =&gt; 320, 'minHeight' =&gt; 200, ]); // Is image size equal to or smaller than 640x480? $validator = new ImageSize([ 'maxWidth' =&gt; 640, 'maxHeight' =&gt; 480, ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.jpg')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/image-size/#public-methods","text":"","title":"Public Methods"},{"location":"v2/validators/file/intro/","text":"File Validation Classes Laminas comes with a set of classes for validating both files and uploaded files, such as file size validation and CRC checking. Count crc32 ExcludeExtension ExcludeMimeType Exists Extension FilesSize Hash ImageSize IsCompressed IsImage Md5 MimeType NotExists Sha1 Size Upload UploadFile WordCount Validation argument All of the File validators' isValid() methods support both a file path string or a $_FILES array as the supplied argument. When a $_FILES array is passed in, the tmp_name is used for the file path.","title":"Introduction"},{"location":"v2/validators/file/intro/#file-validation-classes","text":"Laminas comes with a set of classes for validating both files and uploaded files, such as file size validation and CRC checking. Count crc32 ExcludeExtension ExcludeMimeType Exists Extension FilesSize Hash ImageSize IsCompressed IsImage Md5 MimeType NotExists Sha1 Size Upload UploadFile WordCount","title":"File Validation Classes"},{"location":"v2/validators/file/is-compressed/","text":"IsCompressed Laminas\\Validator\\File\\IsCompressed checks if a file is a compressed archive, such as zip or gzip. This validator is based on the MimeType validator , and supports the same methods and options. The default list of compressed file MIME types can be found in the source code. Please refer to the MimeType validator for options and public methods. Basic Usage $validator = new \\Laminas\\Validator\\File\\IsCompressed(); if ($validator-&gt;isValid('./myfile.zip')) { // file is valid }","title":"IsCompressed"},{"location":"v2/validators/file/is-compressed/#iscompressed","text":"Laminas\\Validator\\File\\IsCompressed checks if a file is a compressed archive, such as zip or gzip. This validator is based on the MimeType validator , and supports the same methods and options. The default list of compressed file MIME types can be found in the source code. Please refer to the MimeType validator for options and public methods.","title":"IsCompressed"},{"location":"v2/validators/file/is-compressed/#basic-usage","text":"$validator = new \\Laminas\\Validator\\File\\IsCompressed(); if ($validator-&gt;isValid('./myfile.zip')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/is-image/","text":"IsImage Laminas\\Validator\\File\\IsImage checks if a file is an image, such as jpg or png. This validator is based on the MimeType validator and supports the same methods and options. The default list of image file MIME types can be found in the source code. Please refer to the MimeType validator for options and public methods. Basic Usage $validator = new Laminas\\Validator\\File\\IsImage(); if ($validator-&gt;isValid('./myfile.jpg')) { // file is valid }","title":"IsImage"},{"location":"v2/validators/file/is-image/#isimage","text":"Laminas\\Validator\\File\\IsImage checks if a file is an image, such as jpg or png. This validator is based on the MimeType validator and supports the same methods and options. The default list of image file MIME types can be found in the source code. Please refer to the MimeType validator for options and public methods.","title":"IsImage"},{"location":"v2/validators/file/is-image/#basic-usage","text":"$validator = new Laminas\\Validator\\File\\IsImage(); if ($validator-&gt;isValid('./myfile.jpg')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/md5/","text":"Md5 Laminas\\Validator\\File\\Md5 allows you to validate if a given file's hashed contents matches the supplied md5 hash(es). It is subclassed from the Hash validator to provide a validator that supports only the MD5 algorithm. Requires the hash extension This validator requires the PHP Hash extension PHP with the md5 algorithm. Supported Options The following set of options are supported: hash : String hash or array of hashes against which to validate. Basic Usage use Laminas\\Validator\\File\\Md5; // Does file have the given hash? $validator = new Md5('3b3652f336522365223'); // Or, check file against multiple hashes $validator = new Md5([ '3b3652f336522365223', 'eb3365f3365ddc65365' ]); // Or use options notation: $validator = new Md5(['hash' =&gt; [ '3b3652f336522365223', 'eb3365f3365ddc65365' ]]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid } Public Methods getMd5 getMd5() : array Returns an array of MD5 hashes against which to validate. addMd5 addMd5(string|array $options) : void Add one or more hashes to validate against. setMd5 setMd5(string|array $options) : void Overwrite any previously set hashes with those specified.","title":"Md5"},{"location":"v2/validators/file/md5/#md5","text":"Laminas\\Validator\\File\\Md5 allows you to validate if a given file's hashed contents matches the supplied md5 hash(es). It is subclassed from the Hash validator to provide a validator that supports only the MD5 algorithm.","title":"Md5"},{"location":"v2/validators/file/md5/#supported-options","text":"The following set of options are supported: hash : String hash or array of hashes against which to validate.","title":"Supported Options"},{"location":"v2/validators/file/md5/#basic-usage","text":"use Laminas\\Validator\\File\\Md5; // Does file have the given hash? $validator = new Md5('3b3652f336522365223'); // Or, check file against multiple hashes $validator = new Md5([ '3b3652f336522365223', 'eb3365f3365ddc65365' ]); // Or use options notation: $validator = new Md5(['hash' =&gt; [ '3b3652f336522365223', 'eb3365f3365ddc65365' ]]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/md5/#public-methods","text":"","title":"Public Methods"},{"location":"v2/validators/file/mime-type/","text":"MimeType Laminas\\Validator\\File\\MimeType checks the MIME type of files. It will assert true when a given file matches any defined MIME type. This validator is inversely related to the ExcludeMimeType validator Compatibility This component will use the FileInfo extension if it is available. If it's not, it will degrade to the mime_content_type() function. And if the function call fails, it will use the MIME type which is given by HTTP. You should be aware of possible security problems when you do not have FileInfo or mime_content_type() available; the MIME type given by HTTP is not secure and can be easily manipulated. Supported Options The following set of options are supported: mimeType : Comma-delimited string of MIME types, or array of MIME types, against which to test. Types can be specific (e.g., image/jpeg ), or refer only to the group (e.g., image ). magicFile : Location of the magicfile to use for MIME type comparisons; defaults to the value of the MAGIC constant. enableHeaderCheck : Boolean flag indicating whether or not to use HTTP headers when determining the MIME type if neither the FileInfo nor mime_magic extensions are available; defaults to false . Basic Usage use Laminas\\Validator\\File\\MimeType; // Only allow 'gif' or 'jpg' files $validator = new MimeType('image/gif,image/jpeg'); // ... or with array notation: $validator = new MimeType(['image/gif', 'image/jpeg']); // ... or restrict to entire group of types: $validator = new MimeType(['image', 'audio']); // Specify a different magicFile: $validator = new MimeType([ 'mimeType' =&gt; ['image/gif', 'image/jpeg'], 'magicFile' =&gt; '/path/to/magicfile.mgx', ]); // Enable HTTP header scanning (do not do this!): $validator = new MimeType([ 'mimeType' =&gt; ['image/gif', 'image/jpeg'], 'enableHeaderCheck' =&gt; true, ]); // Perform validation if ($validator-&gt;isValid('./myfile.jpg')) { // file is valid } Validating MIME groups is potentially dangerous Allowing \"groups\" of MIME types will accept all members of this group, even if your application does not support them. For instance, When you allow image you also allow image/xpixmap and image/vasa , both of which could be problematic.","title":"MimeType"},{"location":"v2/validators/file/mime-type/#mimetype","text":"Laminas\\Validator\\File\\MimeType checks the MIME type of files. It will assert true when a given file matches any defined MIME type. This validator is inversely related to the ExcludeMimeType validator","title":"MimeType"},{"location":"v2/validators/file/mime-type/#supported-options","text":"The following set of options are supported: mimeType : Comma-delimited string of MIME types, or array of MIME types, against which to test. Types can be specific (e.g., image/jpeg ), or refer only to the group (e.g., image ). magicFile : Location of the magicfile to use for MIME type comparisons; defaults to the value of the MAGIC constant. enableHeaderCheck : Boolean flag indicating whether or not to use HTTP headers when determining the MIME type if neither the FileInfo nor mime_magic extensions are available; defaults to false .","title":"Supported Options"},{"location":"v2/validators/file/mime-type/#basic-usage","text":"use Laminas\\Validator\\File\\MimeType; // Only allow 'gif' or 'jpg' files $validator = new MimeType('image/gif,image/jpeg'); // ... or with array notation: $validator = new MimeType(['image/gif', 'image/jpeg']); // ... or restrict to entire group of types: $validator = new MimeType(['image', 'audio']); // Specify a different magicFile: $validator = new MimeType([ 'mimeType' =&gt; ['image/gif', 'image/jpeg'], 'magicFile' =&gt; '/path/to/magicfile.mgx', ]); // Enable HTTP header scanning (do not do this!): $validator = new MimeType([ 'mimeType' =&gt; ['image/gif', 'image/jpeg'], 'enableHeaderCheck' =&gt; true, ]); // Perform validation if ($validator-&gt;isValid('./myfile.jpg')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/not-exists/","text":"NotExists Laminas\\Validator\\File\\NotExists checks for the existence of files in specified directories. This validator is inversely related to the Exists validator . Supported Options The following set of options are supported: directory : Array of directories or comma-delimited string of directories against which to validate. Basic Usage use Laminas\\Validator\\File\\NotExists; // Only allow files that do not exist in ~either~ directories $validator = new NotExists('/tmp,/var/tmp'); // ... or with array notation: $validator = new NotExists(['/tmp', '/var/tmp']); // ... or using options notation: $validator = new NotExists(['directory' =&gt; [ '/tmp', '/var/tmp', ]]); // Perform validation if ($validator-&gt;isValid('/home/myfile.txt')) { // file is valid } Checks against all directories This validator checks whether the specified file does not exist in any of the given directories; validation will fail if the file exists in one (or more) of the given directories.","title":"NotExists"},{"location":"v2/validators/file/not-exists/#notexists","text":"Laminas\\Validator\\File\\NotExists checks for the existence of files in specified directories. This validator is inversely related to the Exists validator .","title":"NotExists"},{"location":"v2/validators/file/not-exists/#supported-options","text":"The following set of options are supported: directory : Array of directories or comma-delimited string of directories against which to validate.","title":"Supported Options"},{"location":"v2/validators/file/not-exists/#basic-usage","text":"use Laminas\\Validator\\File\\NotExists; // Only allow files that do not exist in ~either~ directories $validator = new NotExists('/tmp,/var/tmp'); // ... or with array notation: $validator = new NotExists(['/tmp', '/var/tmp']); // ... or using options notation: $validator = new NotExists(['directory' =&gt; [ '/tmp', '/var/tmp', ]]); // Perform validation if ($validator-&gt;isValid('/home/myfile.txt')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/sha1/","text":"Sha1 Laminas\\Validator\\File\\Sha1 allows you to validate if a given file's hashed contents matches the supplied sha1 hash(es). It is subclassed from the Hash validator to provide a validator that only supports the sha1 algorithm. Requires the hash extension This validator requires the PHP Hash extension with the sha1 algorithm. Supported Options The following set of options are supported: hash : String hash or array of hashes against which to validate. Basic Usage use Laminas\\Validator\\File\\Sha1; // Does file have the given hash? $validator = new Sha1('3b3652f336522365223'); // Or check file against multiple hashes: $validator = new Sha1([ '3b3652f336522365223', 'eb3365f3365ddc65365', ]); // Or using options notation: $validator = new Sha1(['hash' =&gt; [ '3b3652f336522365223', 'eb3365f3365ddc65365', ]]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid } Public Methods getSha1 getSha1() : array Returns an array of sha1 hashes against which to validate. addSha1 addSha1(string|array $options) : void Add one or more hashes to validate against. setSha1 setSha1(string|array $options) : void Overwrite any previously set hashes with those specified.","title":"Sha1"},{"location":"v2/validators/file/sha1/#sha1","text":"Laminas\\Validator\\File\\Sha1 allows you to validate if a given file's hashed contents matches the supplied sha1 hash(es). It is subclassed from the Hash validator to provide a validator that only supports the sha1 algorithm.","title":"Sha1"},{"location":"v2/validators/file/sha1/#supported-options","text":"The following set of options are supported: hash : String hash or array of hashes against which to validate.","title":"Supported Options"},{"location":"v2/validators/file/sha1/#basic-usage","text":"use Laminas\\Validator\\File\\Sha1; // Does file have the given hash? $validator = new Sha1('3b3652f336522365223'); // Or check file against multiple hashes: $validator = new Sha1([ '3b3652f336522365223', 'eb3365f3365ddc65365', ]); // Or using options notation: $validator = new Sha1(['hash' =&gt; [ '3b3652f336522365223', 'eb3365f3365ddc65365', ]]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/sha1/#public-methods","text":"","title":"Public Methods"},{"location":"v2/validators/file/size/","text":"Size Laminas\\Validator\\File\\Size checks for the size of a file. Supported Options The following set of options are supported: min : Minimum file size in integer bytes, or in string SI notation; null indicates no minimum required. max : maximum file size in integer bytes, or in string SI notation; null indicates no maximum required. useByteString : Boolean flag indicating whether to dispaly error messages using SI notation (default, true ), or in bytes ( false ). SI units supported are: kB, MB, GB, TB, PB, and EB. All sizes are converted using 1024 as the base value (ie. 1kB == 1024 bytes, 1MB == 1024kB). Basic Usage use Laminas\\Validator\\File\\Size; // Limit the file size to 40000 bytes $validator = new Size(40000); // Limit the file size to between 10kB and 4MB $validator = new Size([ 'min' =&gt; '10kB', 'max' =&gt; '4MB', ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"Size"},{"location":"v2/validators/file/size/#size","text":"Laminas\\Validator\\File\\Size checks for the size of a file.","title":"Size"},{"location":"v2/validators/file/size/#supported-options","text":"The following set of options are supported: min : Minimum file size in integer bytes, or in string SI notation; null indicates no minimum required. max : maximum file size in integer bytes, or in string SI notation; null indicates no maximum required. useByteString : Boolean flag indicating whether to dispaly error messages using SI notation (default, true ), or in bytes ( false ). SI units supported are: kB, MB, GB, TB, PB, and EB. All sizes are converted using 1024 as the base value (ie. 1kB == 1024 bytes, 1MB == 1024kB).","title":"Supported Options"},{"location":"v2/validators/file/size/#basic-usage","text":"use Laminas\\Validator\\File\\Size; // Limit the file size to 40000 bytes $validator = new Size(40000); // Limit the file size to between 10kB and 4MB $validator = new Size([ 'min' =&gt; '10kB', 'max' =&gt; '4MB', ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/upload-file/","text":"UploadFile Laminas\\Validator\\File\\UploadFile checks whether a single file has been uploaded via a form POST and will return descriptive messages for any upload errors. Basic Usage use Laminas\\Http\\PhpEnvironment\\Request; use Laminas\\Validator\\File\\UploadFile; $request = new Request(); $files = $request-&gt;getFiles(); // i.e. $files['my-upload']['error'] == 0 $validator = new UploadFile(); if ($validator-&gt;isValid($files['my-upload'])) { // file is valid } PSR-7 Support Since 2.11.0 Starting in 2.11.0, you can also pass PSR-7 UploadedFileInterface instances as values to the validator. When valid, getValue() will return the instance validated verbatim: $validator = new UploadFile(); // @var Psr\\Http\\Message\\UploadedFileInterface $uploadedFile if ($validator-&gt;isValid($uploadedFile)) { // file is valid $validInstance = $validator-&gt;getValue(); // === $uploadedFile } Usage with laminas-inputfilter When using laminas-inputfilter's FileInput , this validator will be automatically prepended to the validator chain.","title":"UploadFile"},{"location":"v2/validators/file/upload-file/#uploadfile","text":"Laminas\\Validator\\File\\UploadFile checks whether a single file has been uploaded via a form POST and will return descriptive messages for any upload errors.","title":"UploadFile"},{"location":"v2/validators/file/upload-file/#basic-usage","text":"use Laminas\\Http\\PhpEnvironment\\Request; use Laminas\\Validator\\File\\UploadFile; $request = new Request(); $files = $request-&gt;getFiles(); // i.e. $files['my-upload']['error'] == 0 $validator = new UploadFile(); if ($validator-&gt;isValid($files['my-upload'])) { // file is valid }","title":"Basic Usage"},{"location":"v2/validators/file/upload-file/#psr-7-support","text":"Since 2.11.0 Starting in 2.11.0, you can also pass PSR-7 UploadedFileInterface instances as values to the validator. When valid, getValue() will return the instance validated verbatim: $validator = new UploadFile(); // @var Psr\\Http\\Message\\UploadedFileInterface $uploadedFile if ($validator-&gt;isValid($uploadedFile)) { // file is valid $validInstance = $validator-&gt;getValue(); // === $uploadedFile }","title":"PSR-7 Support"},{"location":"v2/validators/file/upload-file/#usage-with-laminas-inputfilter","text":"When using laminas-inputfilter's FileInput , this validator will be automatically prepended to the validator chain.","title":"Usage with laminas-inputfilter"},{"location":"v2/validators/file/upload/","text":"Upload Laminas\\Validator\\File\\Upload validates that a file upload operation was successful. Supported Options Laminas\\Validator\\File\\Upload supports the following options: files : array of file uploads. This is generally the $_FILES array, but should be normalized per the details in PSR-7 (which is also how the laminas-http Request normalizes the array). Basic Usage use Laminas\\Validator\\File\\Upload; // Using laminas-http's request: $validator = new Upload($request-&gt;getFiles()); // Or using options notation: $validator = new Upload(['files' =&gt; $request-&gt;getFiles()]); // Validate: if ($validator-&gt;isValid('foo')) { // \"foo\" file upload was successful } PSR-7 Support Since 2.11.0 Starting in 2.11.0, you can also pass an array of PSR-7 UploadedFileInterface instances to the constructor, the setFiles() method, or the isValid() method (in the latter case, you are validating that all uploaded files were valid). use Laminas\\Validator\\File\\Upload; // @var Psr\\Http\\Message\\ServerRequestInterface $request $validator = new Upload($request-&gt;getUploadedFiles()); // Or using options notation: $validator = new Upload([ 'files' =&gt; $request-&gt;getUploadedFiles(), ]); // Validate: if ($validator-&gt;isValid('foo')) { // \"foo\" file upload was successful }","title":"Upload"},{"location":"v2/validators/file/upload/#upload","text":"Laminas\\Validator\\File\\Upload validates that a file upload operation was successful.","title":"Upload"},{"location":"v2/validators/file/upload/#supported-options","text":"Laminas\\Validator\\File\\Upload supports the following options: files : array of file uploads. This is generally the $_FILES array, but should be normalized per the details in PSR-7 (which is also how the laminas-http Request normalizes the array).","title":"Supported Options"},{"location":"v2/validators/file/upload/#basic-usage","text":"use Laminas\\Validator\\File\\Upload; // Using laminas-http's request: $validator = new Upload($request-&gt;getFiles()); // Or using options notation: $validator = new Upload(['files' =&gt; $request-&gt;getFiles()]); // Validate: if ($validator-&gt;isValid('foo')) { // \"foo\" file upload was successful }","title":"Basic Usage"},{"location":"v2/validators/file/upload/#psr-7-support","text":"Since 2.11.0 Starting in 2.11.0, you can also pass an array of PSR-7 UploadedFileInterface instances to the constructor, the setFiles() method, or the isValid() method (in the latter case, you are validating that all uploaded files were valid). use Laminas\\Validator\\File\\Upload; // @var Psr\\Http\\Message\\ServerRequestInterface $request $validator = new Upload($request-&gt;getUploadedFiles()); // Or using options notation: $validator = new Upload([ 'files' =&gt; $request-&gt;getUploadedFiles(), ]); // Validate: if ($validator-&gt;isValid('foo')) { // \"foo\" file upload was successful }","title":"PSR-7 Support"},{"location":"v2/validators/file/word-count/","text":"WordCount Laminas\\Validator\\File\\WordCount validates that the number of words within a file match the specified criteria. Supported Options The following set of options are supported: min : the minimum number of words required; null indicates no minimum. max : the maximum number of words required; null indicates no maximum. Basic Usage use Laminas\\Validator\\File\\WordCount; // Limit the amount of words to a maximum of 2000: $validator = new WordCount(2000); // Limit the amount of words to between 100 and 5000: $validator = new WordCount(100, 5000); // ... or use options notation: $validator = new WordCount([ 'min' =&gt; 1000, 'max' =&gt; 5000, ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"WordCount"},{"location":"v2/validators/file/word-count/#wordcount","text":"Laminas\\Validator\\File\\WordCount validates that the number of words within a file match the specified criteria.","title":"WordCount"},{"location":"v2/validators/file/word-count/#supported-options","text":"The following set of options are supported: min : the minimum number of words required; null indicates no minimum. max : the maximum number of words required; null indicates no maximum.","title":"Supported Options"},{"location":"v2/validators/file/word-count/#basic-usage","text":"use Laminas\\Validator\\File\\WordCount; // Limit the amount of words to a maximum of 2000: $validator = new WordCount(2000); // Limit the amount of words to between 100 and 5000: $validator = new WordCount(100, 5000); // ... or use options notation: $validator = new WordCount([ 'min' =&gt; 1000, 'max' =&gt; 5000, ]); // Perform validation with file path if ($validator-&gt;isValid('./myfile.txt')) { // file is valid }","title":"Basic Usage"}]}